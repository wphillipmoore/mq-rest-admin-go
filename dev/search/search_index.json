{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mqrestadmin","text":""},{"location":"#overview","title":"Overview","text":"<p>mqrestadmin provides a Go-friendly interface to IBM MQ queue manager administration via the <code>runCommandJSON</code> REST endpoint. It translates between Go <code>snake_case</code> attribute names and native MQSC parameter names, wraps every MQSC command as a typed method, and handles authentication, CSRF tokens, and error propagation.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>~144 command methods covering all MQSC verbs and qualifiers</li> <li>Bidirectional attribute mapping between developer-friendly names and MQSC parameters</li> <li>Idempotent ensure methods for declarative object management</li> <li>Bulk sync operations for configuration-as-code workflows</li> <li>Zero runtime dependencies \u2014 stdlib only</li> <li>Transport abstraction for easy testing with mock transports</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\n</code></pre>"},{"location":"#status","title":"Status","text":"<p>This project is in pre-alpha (initial setup). The API surface, mapping tables, and return shapes are under active development.</p>"},{"location":"#license","title":"License","text":"<p>GNU General Public License v3.0</p>"},{"location":"ai-engineering/","title":"AI-assisted engineering","text":""},{"location":"ai-engineering/#ai-assisted-engineering_1","title":"AI-assisted engineering","text":""},{"location":"ai-engineering/#go-specific-quality-standards","title":"Go-specific quality standards","text":"<p>Test coverage: All production code is covered by unit tests. Coverage is enforced as a CI hard gate.</p> <p>Race detection: All tests run with <code>go test -race</code> to catch concurrent access issues.</p> <p>Static analysis: golangci-lint runs with a comprehensive linter configuration. Both <code>go vet</code> and additional linters run as CI hard gates.</p> <p>Zero dependencies: The package uses only the Go standard library, eliminating supply-chain risk and keeping the dependency audit trivial.</p>"},{"location":"ai-engineering/#go-specific-quality-standards_1","title":"Go-specific quality standards","text":"<p>Test coverage: All production code is covered by unit tests. Coverage is enforced as a CI hard gate.</p> <p>Race detection: All tests run with <code>go test -race</code> to catch concurrent access issues.</p> <p>Static analysis: golangci-lint runs with a comprehensive linter configuration. Both <code>go vet</code> and additional linters run as CI hard gates.</p> <p>Zero dependencies: The package uses only the Go standard library, eliminating supply-chain risk and keeping the dependency audit trivial.</p>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#component-overview","title":"Component overview","text":"<p>The library is organized around four core components:</p> Session The main entry point. Owns authentication, base URL construction,   request/response handling, and diagnostic state. Provides generated   command methods for all MQSC commands. A single session represents a   connection to one queue manager's REST API. Command methods ~144 generated MQSC command methods. Each method is a thin wrapper that   calls the internal command dispatcher with the correct command verb and   qualifier. Method names follow the pattern <code>verb_qualifier</code> (or   <code>verbQualifier</code> in camelCase languages), mapping directly to MQSC   commands. For example, <code>DISPLAY QUEUE</code> becomes <code>display_queue</code> /   <code>displayQueue</code>, and <code>DEFINE QLOCAL</code> becomes <code>define_qlocal</code> /   <code>defineQlocal</code>. Ensure methods 16 idempotent ensure methods for declarative object management. Each   method checks current state with DISPLAY, then DEFINE, ALTER, or no-ops   as needed. Returns an ensure result indicating what action was taken.   The queue manager variant is a special singleton (no name, no DEFINE).   Only changed attributes are sent in ALTER commands, preserving   <code>ALTDATE</code>/<code>ALTTIME</code> audit timestamps. Mapping pipeline Bidirectional attribute translation between developer-friendly names and   native MQSC parameter names. Includes key mapping (attribute names),   value mapping (enumerated values), and key-value mapping (combined   name+value translations). The mapping tables were bootstrapped from   IBM MQ 9.4 documentation and cover all standard MQSC attributes. Exception hierarchy Structured error types for transport failures, malformed responses,   authentication errors, MQSC command errors, and polling timeouts.   All exceptions carry diagnostic context including the full MQ response   payload when available. <p>In the Go implementation, the core components map to these types:</p> <ul> <li><code>Session</code>: The main entry point. A single struct that owns connection   details, authentication, mapping configuration, diagnostic state, and all   ~144 command methods plus 16 ensure methods and 9 sync methods. Created   via <code>NewSession</code> with functional options.</li> <li>Command methods: Exported methods on <code>Session</code> (e.g. <code>DisplayQueue()</code>,   <code>DefineQlocal()</code>, <code>DeleteChannel()</code>). Each method is a thin wrapper that   calls the internal <code>mqscCommand()</code> dispatcher with the correct verb and   qualifier.</li> <li><code>attributeMapper</code>: Internal type that handles bidirectional attribute   translation using mapping data loaded from an embedded JSON resource. See   the mapping pipeline for details.</li> <li>Error types: Typed error structs (<code>TransportError</code>, <code>CommandError</code>, etc.)   used with <code>errors.As()</code>. All errors are values, not an exception hierarchy.</li> </ul>"},{"location":"architecture/#request-lifecycle","title":"Request lifecycle","text":"<p>Every MQSC command follows the same path through the system:</p> <pre><code>Method call (e.g. displayQueue / display_queue)\n  \u2192 command dispatcher\n    \u2192 Map request attributes (friendly names \u2192 MQSC)\n    \u2192 Map response parameter names\n    \u2192 Map WHERE keyword\n    \u2192 Build runCommandJSON payload\n    \u2192 Transport POST\n    \u2192 Parse JSON response\n    \u2192 Extract commandResponse items\n    \u2192 Flatten nested objects\n    \u2192 Map response attributes (MQSC \u2192 friendly names)\n  \u2192 Return result\n</code></pre>"},{"location":"architecture/#build-phase","title":"Build phase","text":"<ol> <li>The command method calls the internal dispatcher with the MQSC verb (e.g.    <code>DISPLAY</code>), qualifier (e.g. <code>QUEUE</code>), and user-supplied parameters.</li> <li>If mapping is enabled, request attributes are translated from friendly names    to MQSC parameter names via the qualifier's request key map and request    value map.</li> <li>Response parameter names are mapped similarly.</li> <li>A <code>WHERE</code> clause keyword, if provided, is mapped through the same qualifier    key maps.</li> <li>The <code>runCommandJSON</code> payload is assembled and sent via the transport.</li> </ol>"},{"location":"architecture/#parse-phase","title":"Parse phase","text":"<ol> <li>The JSON response is parsed and validated.</li> <li>Error codes (<code>overallCompletionCode</code>, <code>overallReasonCode</code>, per-item    <code>completionCode</code>/<code>reasonCode</code>) are checked. Errors raise a command    exception.</li> <li>The <code>parameters</code> dict is extracted from each <code>commandResponse</code> item.</li> <li>Nested <code>objects</code> lists (e.g. from <code>DISPLAY CONN TYPE(HANDLE)</code>) are    flattened into the parent parameter set.</li> <li>If mapping is enabled, response attributes are translated from MQSC to    friendly names.</li> </ol> <p>In Go, the command dispatcher is the internal <code>mqscCommand()</code> method on <code>Session</code>. Every exported command method (e.g. <code>DisplayQueue()</code>, <code>DefineQlocal()</code>) delegates to it with the appropriate verb and qualifier.</p> <p>The session retains diagnostic state from the most recent command for inspection:</p> <pre><code>session.DisplayQueue(ctx, \"MY.QUEUE\")\n\nsession.LastCommandPayload    // the JSON sent to MQ\nsession.LastResponsePayload   // the parsed JSON response\nsession.LastHTTPStatus        // HTTP status code\nsession.LastResponseText      // raw response body\n</code></pre>"},{"location":"architecture/#transport-abstraction","title":"Transport abstraction","text":"<p>The session object does not make HTTP calls directly. Instead, it delegates to a transport interface that defines a single method for posting JSON payloads:</p> <ul> <li>URL: The fully-qualified endpoint URL.</li> <li>Payload: The <code>runCommandJSON</code> request body.</li> <li>Headers: Authentication, CSRF token, and optional gateway headers.</li> <li>Timeout: Per-request timeout duration.</li> <li>TLS verification: Whether to verify server certificates.</li> </ul> <p>The transport returns a response object containing the HTTP status code, response body, and response headers.</p> <p>The default implementation wraps the language's standard HTTP client. Tests inject a mock transport to avoid network calls, making the entire command pipeline testable without an MQ server.</p> <p>In Go, the transport is defined by the <code>Transport</code> interface:</p> <pre><code>type Transport interface {\n    PostJSON(ctx context.Context, url string, payload map[string]any,\n        headers map[string]string, timeout time.Duration, verifyTLS bool,\n    ) (*TransportResponse, error)\n}\n</code></pre> <p>The default <code>HTTPTransport</code> uses <code>net/http</code>. Custom implementations can be injected via <code>WithTransport()</code> for testing or specialized HTTP handling.</p> <p>For testing, inject a mock transport:</p> <pre><code>type mockTransport struct{}\n\nfunc (m *mockTransport) PostJSON(ctx context.Context, url string,\n    payload map[string]any, headers map[string]string,\n    timeout time.Duration, verifyTLS bool,\n) (*TransportResponse, error) {\n    return &amp;mqrestadmin.TransportResponse{\n        StatusCode: 200,\n        Body:       responseJSON,\n        Headers:    map[string]string{},\n    }, nil\n}\n\nsession, _ := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"admin\", Password: \"pass\"},\n    mqrestadmin.WithTransport(&amp;mockTransport{}),\n)\n</code></pre> <p>This makes the entire command pipeline testable without an MQ server.</p>"},{"location":"architecture/#single-endpoint-design","title":"Single-endpoint design","text":"<p>All MQSC operations go through a single REST endpoint:</p> <pre><code>POST /ibmmq/rest/v2/admin/action/qmgr/{qmgr}/mqsc\n</code></pre> <p>The <code>runCommandJSON</code> payload specifies the MQSC verb, qualifier, object name, parameters, and response parameters. This design means the library needs exactly one HTTP method and one URL pattern to cover all MQSC commands.</p> <p>In Go, this means every command method on <code>Session</code> ultimately calls the same <code>PostJSON()</code> method on the transport with the same URL pattern. The only variation is the JSON payload content.</p>"},{"location":"architecture/#gateway-routing","title":"Gateway routing","text":"<p>The MQ REST API is available on all supported IBM MQ platforms (Linux, AIX, Windows, z/OS, and IBM i). The library is developed and tested against the Linux implementation.</p> <p>In enterprise environments, a gateway queue manager can route MQSC commands to remote queue managers via MQ channels \u2014 the same mechanism used by <code>runmqsc -w</code> and the MQ Console.</p> <p>When a gateway queue manager is configured on the session:</p> <ul> <li>The URL path targets the remote queue manager:   <code>POST /admin/action/qmgr/{TARGET_QM}/mqsc</code></li> <li>The <code>ibm-mq-rest-gateway-qmgr</code> HTTP header names the local queue manager   that routes the command.</li> </ul> <p>When no gateway is configured (the default), no gateway header is sent and the REST API talks directly to the queue manager in the URL. This makes the feature purely additive \u2014 existing sessions are unaffected.</p> <pre><code>Client                     Gateway QM (QM1)              Target QM (QM2)\n  \u2502                              \u2502                              \u2502\n  \u2502  POST /qmgr/QM2/mqsc        \u2502                              \u2502\n  \u2502  Header: gateway-qmgr=QM1   \u2502                              \u2502\n  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502   MQSC via MQ channel        \u2502\n  \u2502                              \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n  \u2502                              \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502\n  \u2502&lt;\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2502                              \u2502\n</code></pre>"},{"location":"architecture/#prerequisites","title":"Prerequisites","text":"<ul> <li>The gateway queue manager must have a running REST API.</li> <li>MQ channels must be configured between the gateway and target queue managers.</li> <li>A QM alias (QREMOTE with empty RNAME) must map the target QM name to the   correct transmission queue on the gateway.</li> </ul> <p>In Go, configure gateway routing via a functional option:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://qm1-host:9443/ibmmq/rest/v2\",\n    \"QM2\",                                      // target (remote) queue manager\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithGatewayQmgr(\"QM1\"),         // local gateway queue manager\n)\n</code></pre>"},{"location":"architecture/#context-support","title":"Context support","text":"<p>All I/O methods accept <code>context.Context</code> as their first parameter, enabling cancellation, timeouts, and tracing integration.</p>"},{"location":"architecture/#zero-dependencies","title":"Zero dependencies","text":"<p>The package uses only the Go standard library:</p> <ul> <li><code>net/http</code> for HTTP</li> <li><code>encoding/json</code> for JSON</li> <li><code>crypto/tls</code> for TLS/mTLS</li> <li><code>embed</code> for mapping data</li> </ul>"},{"location":"architecture/#ensure-pipeline","title":"Ensure pipeline","text":"<p>See ensure methods for details on the idempotent create-or-update pipeline.</p>"},{"location":"architecture/#sync-pipeline","title":"Sync pipeline","text":"<p>See sync methods for details on the synchronous polling pipeline.</p>"},{"location":"ensure-methods/","title":"Declarative Object Management","text":""},{"location":"ensure-methods/#the-problem-with-alter","title":"The problem with ALTER","text":"<p>Every <code>Alter*()</code> call sends an <code>ALTER</code> command to the queue manager, even when every specified attribute already matches the current state. MQ updates <code>ALTDATE</code> and <code>ALTTIME</code> on every <code>ALTER</code>, regardless of whether any values actually changed. This makes <code>ALTER</code> unsuitable for declarative configuration management where idempotency matters -- running the same configuration twice should not corrupt audit timestamps.</p>"},{"location":"ensure-methods/#the-ensure-pattern","title":"The ensure pattern","text":"<p>The <code>Ensure*()</code> methods implement a declarative upsert pattern:</p> <ol> <li>DEFINE the object when it does not exist.</li> <li>ALTER only the attributes that differ from the current state.</li> <li>Do nothing when all specified attributes already match,    preserving <code>ALTDATE</code> and <code>ALTTIME</code>.</li> </ol> <p>Each call returns an <code>EnsureResult</code> indicating what action was taken:</p> <pre><code>// EnsureAction constants:\n//   EnsureCreated   -- Object did not exist, was defined\n//   EnsureUpdated   -- Object existed, attributes were altered\n//   EnsureUnchanged -- Object existed, no changes needed\n\n// EnsureResult struct:\n//   Action  EnsureAction  -- the action taken\n//   Changed []string      -- attribute names that triggered ALTER\n</code></pre>"},{"location":"ensure-methods/#basic-usage","title":"Basic usage","text":"<pre><code>ctx := context.Background()\n\n// First call -- queue does not exist yet\nresult, err := session.EnsureQlocal(ctx, \"APP.REQUEST.Q\", map[string]any{\n    \"max_queue_depth\": 50000,\n    \"description\":     \"Application request queue\",\n})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(result.Action) // \"created\"\n\n// Second call -- same attributes, nothing to change\nresult, err = session.EnsureQlocal(ctx, \"APP.REQUEST.Q\", map[string]any{\n    \"max_queue_depth\": 50000,\n    \"description\":     \"Application request queue\",\n})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(result.Action) // \"unchanged\"\n\n// Third call -- description changed, only that attribute is altered\nresult, err = session.EnsureQlocal(ctx, \"APP.REQUEST.Q\", map[string]any{\n    \"max_queue_depth\": 50000,\n    \"description\":     \"Updated request queue\",\n})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(result.Action)  // \"updated\"\nfmt.Println(result.Changed) // [\"description\"]\n</code></pre>"},{"location":"ensure-methods/#comparison-logic","title":"Comparison logic","text":"<p>The ensure methods compare only the attributes the caller passes in <code>requestParameters</code> against the current state returned by <code>DISPLAY</code>. Attributes not specified by the caller are ignored.</p> <p>Comparison is:</p> <ul> <li>Case-insensitive -- <code>\"ENABLED\"</code> matches <code>\"enabled\"</code>.</li> <li>Type-normalizing -- integer <code>5000</code> matches string <code>\"5000\"</code>.</li> <li>Whitespace-trimming -- <code>\" YES \"</code> matches <code>\"YES\"</code>.</li> </ul> <p>An attribute present in <code>requestParameters</code> but absent from the <code>DISPLAY</code> response is treated as changed and included in the <code>ALTER</code>.</p>"},{"location":"ensure-methods/#selective-alter","title":"Selective ALTER","text":"<p>When an update is needed, only the changed attributes are sent in the <code>ALTER</code> command. Attributes that already match are excluded from the request. This minimizes the scope of each <code>ALTER</code> to the strict delta.</p>"},{"location":"ensure-methods/#available-methods","title":"Available methods","text":"<p>Each method targets a specific MQ object type with the correct MQSC qualifier triple (DISPLAY / DEFINE / ALTER):</p> Method Object type DISPLAY DEFINE ALTER <code>EnsureQmgr()</code> Queue manager <code>QMGR</code> -- <code>QMGR</code> <code>EnsureQlocal()</code> Local queue <code>QUEUE</code> <code>QLOCAL</code> <code>QLOCAL</code> <code>EnsureQremote()</code> Remote queue <code>QUEUE</code> <code>QREMOTE</code> <code>QREMOTE</code> <code>EnsureQalias()</code> Alias queue <code>QUEUE</code> <code>QALIAS</code> <code>QALIAS</code> <code>EnsureQmodel()</code> Model queue <code>QUEUE</code> <code>QMODEL</code> <code>QMODEL</code> <code>EnsureChannel()</code> Channel <code>CHANNEL</code> <code>CHANNEL</code> <code>CHANNEL</code> <code>EnsureAuthinfo()</code> Auth info <code>AUTHINFO</code> <code>AUTHINFO</code> <code>AUTHINFO</code> <code>EnsureListener()</code> Listener <code>LISTENER</code> <code>LISTENER</code> <code>LISTENER</code> <code>EnsureNamelist()</code> Namelist <code>NAMELIST</code> <code>NAMELIST</code> <code>NAMELIST</code> <code>EnsureProcess()</code> Process <code>PROCESS</code> <code>PROCESS</code> <code>PROCESS</code> <code>EnsureService()</code> Service <code>SERVICE</code> <code>SERVICE</code> <code>SERVICE</code> <code>EnsureTopic()</code> Topic <code>TOPIC</code> <code>TOPIC</code> <code>TOPIC</code> <code>EnsureSub()</code> Subscription <code>SUB</code> <code>SUB</code> <code>SUB</code> <code>EnsureStgclass()</code> Storage class <code>STGCLASS</code> <code>STGCLASS</code> <code>STGCLASS</code> <code>EnsureComminfo()</code> Comm info <code>COMMINFO</code> <code>COMMINFO</code> <code>COMMINFO</code> <code>EnsureCfstruct()</code> CF structure <code>CFSTRUCT</code> <code>CFSTRUCT</code> <code>CFSTRUCT</code> <p>Most methods share the same signature:</p> <pre><code>func (session *Session) EnsureQlocal(ctx context.Context, name string, requestParameters map[string]any) (EnsureResult, error)\n</code></pre> <p>All ensure methods take <code>context.Context</code> as their first parameter, following standard Go conventions for I/O operations.</p> <p><code>responseParameters</code> is not exposed -- the ensure logic always requests <code>[\"all\"]</code> internally so it can compare the full current state.</p>"},{"location":"ensure-methods/#queue-manager-singleton","title":"Queue manager (singleton)","text":"<p><code>EnsureQmgr()</code> has no <code>name</code> parameter because the queue manager is a singleton that always exists. It can only return <code>EnsureUpdated</code> or <code>EnsureUnchanged</code> (never <code>EnsureCreated</code>):</p> <pre><code>func (session *Session) EnsureQmgr(ctx context.Context, requestParameters map[string]any) (EnsureResult, error)\n</code></pre> <p>This makes it ideal for asserting queue manager-level settings such as statistics, monitoring, events, and logging attributes without corrupting <code>ALTDATE</code>/<code>ALTTIME</code> on every run.</p>"},{"location":"ensure-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The ensure methods participate in the same mapping pipeline as all other command methods. Pass <code>snake_case</code> attribute names in <code>requestParameters</code> and the mapping layer translates them to MQSC names for the DISPLAY, DEFINE, and ALTER commands automatically.</p>"},{"location":"ensure-methods/#configuration-management-example","title":"Configuration management example","text":"<p>The ensure pattern is designed for programs that declare desired state:</p> <pre><code>func configureQueueManager(ctx context.Context, session *mqrestadmin.Session) error {\n    // Ensure queue manager settings\n    result, err := session.EnsureQmgr(ctx, map[string]any{\n        \"queue_statistics\":   \"on\",\n        \"channel_statistics\": \"on\",\n        \"queue_monitoring\":   \"medium\",\n        \"channel_monitoring\": \"medium\",\n    })\n    if err != nil {\n        return fmt.Errorf(\"ensure qmgr: %w\", err)\n    }\n    fmt.Printf(\"Queue manager: %s\\n\", result.Action)\n\n    // Ensure application queues\n    queues := map[string]map[string]any{\n        \"APP.REQUEST.Q\": {\"max_queue_depth\": 50000, \"default_persistence\": \"yes\"},\n        \"APP.REPLY.Q\":   {\"max_queue_depth\": 10000, \"default_persistence\": \"no\"},\n        \"APP.DLQ\":       {\"max_queue_depth\": 100000, \"default_persistence\": \"yes\"},\n    }\n\n    for name, attrs := range queues {\n        result, err := session.EnsureQlocal(ctx, name, attrs)\n        if err != nil {\n            return fmt.Errorf(\"ensure %s: %w\", name, err)\n        }\n        fmt.Printf(\"%s: %s\\n\", name, result.Action)\n    }\n\n    return nil\n}\n</code></pre> <p>Running this function repeatedly produces no side effects when the configuration is already correct. Only genuine changes trigger <code>ALTER</code> commands, keeping <code>ALTDATE</code>/<code>ALTTIME</code> accurate.</p>"},{"location":"examples/","title":"Examples","text":"<p>The <code>examples/</code> directory contains practical scripts that demonstrate common MQ administration tasks using <code>mqrestadmin</code>. Each example is self-contained and can be run against the local Docker environment.</p>"},{"location":"examples/#prerequisites","title":"Prerequisites","text":"<p>Start the multi-queue-manager Docker environment and seed both queue managers:</p> <pre><code>./scripts/dev/mq_start.sh\n./scripts/dev/mq_seed.sh\n</code></pre> <p>This starts two queue managers (<code>QM1</code> on port 9443, <code>QM2</code> on port 9444) on a shared Docker network. See local MQ container for details.</p>"},{"location":"examples/#health-check","title":"Health check","text":"<p>Connect to one or more queue managers and check:</p> <ul> <li>Queue manager attributes via <code>DisplayQmgr()</code></li> <li>Running status via <code>DisplayQmstatus()</code></li> <li>Listener definitions via <code>DisplayListener()</code></li> </ul> <pre><code>ctx := context.Background()\n\nqmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"Queue manager:\", qmgr[\"queue_manager_name\"])\n\nstatus, err := session.DisplayQmstatus(ctx)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(\"Status:\", status[\"channel_initiator_status\"])\n\nlisteners, err := session.DisplayListener(ctx, \"*\")\nif err != nil {\n    log.Fatal(err)\n}\nfor _, listener := range listeners {\n    fmt.Printf(\"Listener: %s port=%v\\n\",\n        listener[\"listener_name\"], listener[\"port\"])\n}\n</code></pre>"},{"location":"examples/#queue-depth-monitor","title":"Queue depth monitor","text":"<p>Display all local queues with their current depth and flag queues approaching capacity:</p> <pre><code>ctx := context.Background()\n\nqueues, err := session.DisplayQueue(ctx, \"*\")\nif err != nil {\n    log.Fatal(err)\n}\n\nfor _, queue := range queues {\n    depth, _ := strconv.Atoi(fmt.Sprint(queue[\"current_queue_depth\"]))\n    maxDepth, _ := strconv.Atoi(fmt.Sprint(queue[\"max_queue_depth\"]))\n    pct := 0\n    if maxDepth &gt; 0 {\n        pct = depth * 100 / maxDepth\n    }\n    flag := \"\"\n    if pct &gt; 80 {\n        flag = \" *** HIGH ***\"\n    }\n    fmt.Printf(\"%-40s %5d / %5d (%d%%)%s\\n\",\n        queue[\"queue_name\"], depth, maxDepth, pct, flag)\n}\n</code></pre>"},{"location":"examples/#channel-status-report","title":"Channel status report","text":"<p>Cross-reference channel definitions with live channel status:</p> <pre><code>ctx := context.Background()\n\nchannels, err := session.DisplayChannel(ctx, \"*\")\nif err != nil {\n    log.Fatal(err)\n}\n\nstatuses, err := session.DisplayChstatus(ctx, \"*\")\nif err != nil {\n    log.Fatal(err)\n}\n\nrunning := make(map[string]bool)\nfor _, s := range statuses {\n    running[fmt.Sprint(s[\"channel_name\"])] = true\n}\n\nfor _, ch := range channels {\n    name := fmt.Sprint(ch[\"channel_name\"])\n    state := \"INACTIVE\"\n    if running[name] {\n        state = \"RUNNING\"\n    }\n    fmt.Println(name + \": \" + state)\n}\n</code></pre>"},{"location":"examples/#environment-provisioner","title":"Environment provisioner","text":"<p>Demonstrate bulk provisioning across two queue managers using ensure methods:</p> <pre><code>ctx := context.Background()\n\n// Ensure application queues exist on QM1\n_, err := session.EnsureQlocal(ctx, \"APP.REQUESTS\", map[string]any{\n    \"max_queue_depth\":     \"50000\",\n    \"default_persistence\": \"persistent\",\n})\nif err != nil {\n    log.Fatal(err)\n}\n\n_, err = session.EnsureQlocal(ctx, \"APP.RESPONSES\", map[string]any{\n    \"max_queue_depth\":     \"50000\",\n    \"default_persistence\": \"persistent\",\n})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Ensure listeners are running\nconfig := mqrestadmin.SyncConfig{Timeout: 60 * time.Second}\n_, err = session.StartListenerSync(ctx, \"TCP.LISTENER\", config)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(\"Environment provisioned\")\n</code></pre>"},{"location":"examples/#dead-letter-queue-inspector","title":"Dead letter queue inspector","text":"<p>Inspect the dead letter queue configuration:</p> <pre><code>ctx := context.Background()\n\nqmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    log.Fatal(err)\n}\n\ndlqName, ok := qmgr[\"dead_letter_q_name\"].(string)\nif ok &amp;&amp; dlqName != \"\" {\n    dlq, err := session.DisplayQueue(ctx, dlqName)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if len(dlq) &gt; 0 {\n        fmt.Printf(\"DLQ: %s depth=%v max=%v\\n\",\n            dlqName, dlq[0][\"current_queue_depth\"], dlq[0][\"max_queue_depth\"])\n    }\n} else {\n    fmt.Println(\"No dead letter queue configured\")\n}\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Go: 1.25 or later</li> <li>IBM MQ: A running queue manager with the administrative REST API enabled</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>go get github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\n</code></pre>"},{"location":"getting-started/#creating-a-session","title":"Creating a session","text":"<p>All interaction with IBM MQ goes through a <code>Session</code>. You need the REST API base URL, queue manager name, and credentials:</p> <pre><code>package main\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\"\n)\n\nfunc main() {\n    session, err := mqrestadmin.NewSession(\n        \"https://localhost:9443/ibmmq/rest/v2\",\n        \"QM1\",\n        mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n        mqrestadmin.WithTimeout(30*time.Second),\n        mqrestadmin.WithVerifyTLS(false), // for local development only\n    )\n    if err != nil {\n        panic(err)\n    }\n    _ = session\n}\n</code></pre>"},{"location":"getting-started/#running-a-command","title":"Running a command","text":"<p>Every MQSC command has a corresponding method on the session. Method names follow the pattern <code>VerbQualifier</code> in PascalCase:</p> <pre><code>ctx := context.Background()\n\n// DISPLAY QUEUE \u2014 returns a slice of maps\nqueues, err := session.DisplayQueue(ctx, \"*\")\nif err != nil {\n    panic(err)\n}\n\nfor _, queue := range queues {\n    fmt.Println(queue[\"queue_name\"], queue[\"current_queue_depth\"])\n}\n</code></pre> <pre><code>// DISPLAY QMGR \u2014 returns a single map or nil\nqmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    panic(err)\n}\nif qmgr != nil {\n    fmt.Println(qmgr[\"queue_manager_name\"])\n}\n</code></pre>"},{"location":"getting-started/#attribute-mapping","title":"Attribute mapping","text":"<p>By default, the session maps between developer-friendly <code>snake_case</code> names and MQSC parameter names. This applies to both request and response attributes:</p> <pre><code>// With mapping enabled (default)\nqueues, _ := session.DisplayQueue(ctx, \"MY.QUEUE\",\n    map[string]any{\"response_parameters\": []string{\"current_queue_depth\", \"max_queue_depth\"}},\n)\n// Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n// With mapping disabled\nqueues, _ = session.DisplayQueue(ctx, \"MY.QUEUE\",\n    map[string]any{\"response_parameters\": []string{\"CURDEPTH\", \"MAXDEPTH\"}},\n)\n// Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre> <p>Mapping can be disabled at the session level:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithMapAttributes(false),\n)\n</code></pre> <p>See mapping pipeline for a detailed explanation of how mapping works.</p>"},{"location":"getting-started/#strict-vs-lenient-mapping","title":"Strict vs lenient mapping","text":"<p>By default, mapping runs in lenient mode. Unknown attribute names or values pass through unchanged. In strict mode, unknown attributes return an error:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithStrictMapping(true),\n)\n</code></pre>"},{"location":"getting-started/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>Sites with existing naming conventions can override individual entries in the built-in mapping tables without replacing them entirely. Pass override data when creating the session:</p> <pre><code>overrideData := map[string]any{\n    \"qualifiers\": map[string]any{\n        \"queue\": map[string]any{\n            \"response_key_map\": map[string]any{\n                \"CURDEPTH\": \"queue_depth\",      // override built-in mapping\n                \"MAXDEPTH\": \"queue_max_depth\",   // override built-in mapping\n            },\n        },\n    },\n}\n\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithMappingOverride(overrideData, mqrestadmin.MergeOverride),\n)\n\nqueues, _ := session.DisplayQueue(ctx, \"MY.QUEUE\")\n// Returns: [{\"queue_depth\": 0, \"queue_max_depth\": 5000, ...}]\n</code></pre> <p>Overrides are sparse \u2014 you only specify the entries you want to change. All other mappings in the qualifier continue to work as normal. In the example above, only <code>CURDEPTH</code> and <code>MAXDEPTH</code> are remapped; every other queue attribute keeps its default <code>snake_case</code> name.</p> <p>Overrides support all five sub-maps per qualifier: <code>request_key_map</code>, <code>request_value_map</code>, <code>request_key_value_map</code>, <code>response_key_map</code>, and <code>response_value_map</code>. See mapping pipeline for details on how each sub-map is used.</p>"},{"location":"getting-started/#gateway-queue-manager","title":"Gateway queue manager","text":"<p>The MQ REST API is available on all supported IBM MQ platforms (Linux, AIX, Windows, z/OS, and IBM i). mqrestadmin is developed and tested against the Linux implementation only.</p> <p>In enterprise environments, a gateway queue manager can route MQSC commands to remote queue managers via MQ channels \u2014 the same mechanism used by <code>runmqsc -w</code> and the MQ Console.</p> <p>To use a gateway, pass <code>WithGatewayQmgr</code> when creating the session. The base URL and queue manager name specify the target (remote) queue manager, while <code>WithGatewayQmgr</code> names the local queue manager whose REST API routes the command:</p> <pre><code>// Route commands to QM2 through QM1's REST API\nsession, err := mqrestadmin.NewSession(\n    \"https://qm1-host:9443/ibmmq/rest/v2\",\n    \"QM2\",                                     // target queue manager\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithGatewayQmgr(\"QM1\"),        // local gateway queue manager\n    mqrestadmin.WithVerifyTLS(false),\n)\n\nqmgr, _ := session.DisplayQmgr(ctx)\n// Returns QM2's queue manager attributes, routed through QM1\n</code></pre> <p>Prerequisites:</p> <ul> <li>The gateway queue manager must have a running REST API.</li> <li>MQ channels must be configured between the gateway and target queue managers.</li> <li>A QM alias (QREMOTE with empty RNAME) must map the target QM name to the   correct transmission queue on the gateway.</li> </ul>"},{"location":"getting-started/#error-handling","title":"Error handling","text":"<p><code>DISPLAY</code> commands return an empty slice when no objects match. Queue manager display methods return <code>nil</code> when no match is found. Non-display commands return a <code>*CommandError</code> on failure:</p> <pre><code>// Empty slice \u2014 no error\nresult, err := session.DisplayQueue(ctx, \"NONEXISTENT.*\")\n// result == []\n\n// Define returns error on failure\nvar cmdErr *mqrestadmin.CommandError\nerr = session.DefineQlocal(ctx, \"MY.QUEUE\", nil)\nif errors.As(err, &amp;cmdErr) {\n    fmt.Println(cmdErr.Error())\n    fmt.Println(\"HTTP status:\", cmdErr.StatusCode)\n    fmt.Println(cmdErr.Payload) // full MQ response payload\n}\n</code></pre>"},{"location":"getting-started/#diagnostic-state","title":"Diagnostic state","text":"<p>The session retains the most recent request and response for inspection:</p> <pre><code>session.DisplayQueue(ctx, \"MY.QUEUE\")\n\nfmt.Println(session.LastCommandPayload)    // the JSON sent to MQ\nfmt.Println(session.LastResponsePayload)   // the parsed JSON response\nfmt.Println(session.LastHTTPStatus)        // HTTP status code\nfmt.Println(session.LastResponseText)      // raw response body\n</code></pre>"},{"location":"mapping-pipeline/","title":"Mapping Pipeline","text":""},{"location":"mapping-pipeline/#the-three-namespace-problem","title":"The three-namespace problem","text":"<p>IBM MQ uses multiple naming conventions depending on the interface:</p> MQSC names (e.g. <code>CURDEPTH</code>, <code>DEFPSIST</code>) Short, uppercase tokens used in MQSC commands and the REST API's   <code>runCommandJSON</code> endpoint. PCF names (e.g. <code>CurrentQDepth</code>, <code>DefPersistence</code>) CamelCase names from the Programmable Command Formats. Not used   directly by <code>mqrestadmin</code>, but they form the intermediate namespace in   the mapping pipeline. Developer names (e.g. <code>current_queue_depth</code>, <code>default_persistence</code>) Human-readable <code>snake_case</code> names for use in application code. <p>The mapping pipeline translates between MQSC and developer names. PCF names were used as an intermediate reference during the original extraction process that bootstrapped the mapping tables but do not appear at runtime.</p> <p>In Go, developer-friendly names use <code>snake_case</code> (e.g. <code>current_queue_depth</code>, <code>default_persistence</code>), matching the convention across the mq-rest-admin library family. The mapping tables are loaded from an embedded JSON resource via Go's <code>embed</code> package and are identical across language implementations.</p> <pre><code>ctx := context.Background()\n\n// With mapping enabled (default) -- developer-friendly names\nqueues, err := session.DisplayQueue(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithResponseParameters([]string{\"current_queue_depth\", \"max_queue_depth\"}))\n// Returns: [{\"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000}]\n\n// With mapping disabled -- native MQSC names\n// (create session with WithMapAttributes(false))\nqueues, err = session.DisplayQueue(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithResponseParameters([]string{\"CURDEPTH\", \"MAXDEPTH\"}))\n// Returns: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000}]\n</code></pre>"},{"location":"mapping-pipeline/#qualifier-based-mapping","title":"Qualifier-based mapping","text":"<p>Mappings are organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>), not by command. A single qualifier's mapping tables serve all commands that operate on that object type. For example, the <code>queue</code> qualifier covers <code>DISPLAY QUEUE</code>, <code>DEFINE QLOCAL</code>, <code>DELETE QALIAS</code>, and all other queue-related commands.</p> <p>This design avoids duplicating mapping data across commands and reflects how MQSC attributes are shared across command verbs.</p> <p>See the Qualifier Mapping Reference for the complete per-qualifier documentation, including every key map, value map, and key-value map entry.</p>"},{"location":"mapping-pipeline/#request-mapping-flow","title":"Request mapping flow","text":"<p>When mapping is enabled, request attributes are translated before sending to the MQ REST API:</p> <ol> <li> <p>Key mapping: Each <code>snake_case</code> attribute name is looked up in the    qualifier's <code>request_key_map</code>. If found, the key is replaced with the    MQSC parameter name.</p> </li> <li> <p>Value mapping: For attributes with enumerated values, the    qualifier's <code>request_value_map</code> translates developer values to MQSC    values (e.g. <code>\"yes\"</code> to <code>\"YES\"</code>).</p> </li> <li> <p>Key-value mapping: Some attributes require both key and value to    change simultaneously. The <code>request_key_value_map</code> handles cases    where a single developer attribute expands to a different MQSC key+value    pair (e.g. <code>channel_type=\"server_connection\"</code> to    <code>CHLTYPE(\"SVRCONN\")</code>).</p> </li> </ol>"},{"location":"mapping-pipeline/#go-example","title":"Go example","text":"<pre><code>ctx := context.Background()\n\n// Developer-friendly request parameters\n_, err := session.DefineQlocal(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithRequestParameters(map[string]any{\n        \"max_queue_depth\":      50000,\n        \"default_persistence\":  \"yes\",\n        \"description\":          \"Application queue\",\n    }))\n\n// After request mapping, the JSON payload sent to MQ contains:\n// { \"MAXDEPTH\": 50000, \"DEFPSIST\": \"YES\", \"DESCR\": \"Application queue\" }\n</code></pre>"},{"location":"mapping-pipeline/#response-mapping-flow","title":"Response mapping flow","text":"<p>Response attributes are translated after receiving the MQ REST response:</p> <ol> <li> <p>Key mapping: Each MQSC parameter name from the response is looked    up in the qualifier's <code>response_key_map</code>. If found, the key is    replaced with the <code>snake_case</code> name.</p> </li> <li> <p>Value mapping: Enumerated MQSC values are translated to    developer-friendly values via the <code>response_value_map</code> (e.g. <code>\"YES\"</code> to    <code>\"yes\"</code>).</p> </li> </ol>"},{"location":"mapping-pipeline/#go-example_1","title":"Go example","text":"<pre><code>ctx := context.Background()\n\n// Request specific response attributes using developer-friendly names\nqueues, err := session.DisplayQueue(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithResponseParameters([]string{\"current_queue_depth\", \"max_queue_depth\"}))\n\n// MQ returns MQSC names in the response:\n// { \"queue\": \"MY.QUEUE\", \"curdepth\": 0, \"maxdepth\": 5000 }\n\n// After response mapping, the caller receives developer-friendly names:\n// { \"queue_name\": \"MY.QUEUE\", \"current_queue_depth\": 0, \"max_queue_depth\": 5000 }\n</code></pre>"},{"location":"mapping-pipeline/#response-parameter-mapping","title":"Response parameter mapping","text":"<p>When the caller specifies response parameters (the list of attributes to return), those names are also mapped from <code>snake_case</code> to MQSC before being sent in the request. This allows callers to request specific attributes using developer-friendly names.</p> <p>Response parameter macros (like <code>CFCONLOS</code> for channel status) are recognized and passed through without mapping.</p>"},{"location":"mapping-pipeline/#where-keyword-mapping","title":"WHERE keyword mapping","text":"<p>The <code>where</code> parameter on DISPLAY methods accepts a filter expression like <code>\"current_queue_depth GT 100\"</code>. The first token (the keyword) is mapped from <code>snake_case</code> to the MQSC name. The rest of the expression is passed through unchanged.</p>"},{"location":"mapping-pipeline/#qualifier-resolution","title":"Qualifier resolution","text":"<p>When a command is executed, the mapping qualifier is resolved by:</p> <ol> <li>Looking up the command key (e.g. <code>\"DISPLAY QUEUE\"</code>) in    the commands section of the mapping data for an explicit qualifier.</li> <li>Falling back to a hardcoded default map (e.g. <code>QLOCAL</code> to <code>queue</code>,    <code>CHANNEL</code> to <code>channel</code>).</li> <li>As a last resort, lowercasing the MQSC qualifier.</li> </ol> <p>This means <code>DEFINE QLOCAL</code>, <code>DEFINE QREMOTE</code>, and <code>DISPLAY QUEUE</code> all resolve to the <code>queue</code> qualifier and share the same mapping tables.</p>"},{"location":"mapping-pipeline/#strict-vs-lenient-mode","title":"Strict vs lenient mode","text":"<p>Strict mode (default): Any attribute name or value that cannot be mapped causes a <code>*MappingError</code> to be returned. This catches typos and unsupported attributes early.</p> <p>Lenient mode (<code>WithMappingStrict(false)</code>): Unknown attribute names and values pass through unchanged. This is useful when working with attributes not yet covered by the mapping tables.</p> <p>The mode is set at session construction and applies to all mapping operations. It cannot be overridden per-call.</p> <p>In Go, the mode is set via a session option:</p> <pre><code>// Strict mode (default) -- returns *MappingError on unknown attributes\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMappingStrict(true), // default\n)\n\n// Lenient mode -- unknown attributes pass through unchanged\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMappingStrict(false),\n)\n</code></pre>"},{"location":"mapping-pipeline/#custom-mapping-overrides","title":"Custom mapping overrides","text":"<p>The built-in mapping tables cover all standard MQSC attributes, but sites may use different <code>snake_case</code> conventions. The <code>WithMappingOverrides</code> option on <code>NewSession</code> lets you layer sparse changes on top of the built-in data without replacing it.</p>"},{"location":"mapping-pipeline/#how-merging-works","title":"How merging works","text":"<p>Overrides are merged at the key level within each sub-map. You only specify the entries you want to change -- all other mappings remain intact:</p> <pre><code>overrides := map[string]any{\n    \"qualifiers\": map[string]any{\n        \"queue\": map[string]any{\n            \"response_key_map\": map[string]any{\n                \"CURDEPTH\": \"queue_depth\",     // override built-in mapping\n                \"MAXDEPTH\": \"queue_max_depth\",  // override built-in mapping\n            },\n        },\n    },\n}\n\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMappingOverrides(overrides, mqrestadmin.MappingOverrideMerge),\n)\n\nctx := context.Background()\nqueues, err := session.DisplayQueue(ctx, \"MY.QUEUE\")\n// Returns: [{\"queue_depth\": 0, \"queue_max_depth\": 5000, ...}]\n// All other queue attributes keep their default names\n</code></pre> <p>When this override is applied:</p> <ol> <li>The built-in mapping data is deep-copied (the original is never mutated).</li> <li>The <code>queue</code> qualifier's <code>response_key_map</code> is updated: the entry for    <code>CURDEPTH</code> changes from <code>\"current_queue_depth\"</code> to <code>\"queue_depth\"</code>.</li> <li>All other entries in <code>response_key_map</code> (and all other sub-maps) remain    unchanged.</li> </ol>"},{"location":"mapping-pipeline/#override-modes","title":"Override modes","text":"<p>The <code>WithMappingOverrides</code> option accepts a <code>MappingOverrideMode</code> that controls how overrides are applied:</p> <ul> <li><code>MappingOverrideMerge</code>: Overlays overrides onto the default mapping   data, adding or replacing individual entries within each sub-map. This is   the most common mode.</li> <li><code>MappingOverrideReplace</code>: Replaces entire qualifier sections with the   override data. Use this when you want to completely redefine a qualifier's   mappings.</li> </ul>"},{"location":"mapping-pipeline/#supported-override-keys","title":"Supported override keys","text":"<p>The top level of the overrides map accepts two keys:</p> <ul> <li><code>commands</code>: Override command-level metadata (e.g. which qualifier a   command resolves to). Each command entry is shallow-merged.</li> <li><code>qualifiers</code>: Override qualifier mapping tables. Each qualifier supports   five sub-maps:</li> <li><code>request_key_map</code> -- <code>snake_case</code> to MQSC key mapping for requests</li> <li><code>request_value_map</code> -- value translations for request attributes</li> <li><code>request_key_value_map</code> -- combined key+value translations for requests</li> <li><code>response_key_map</code> -- MQSC to <code>snake_case</code> key mapping for responses</li> <li><code>response_value_map</code> -- value translations for response attributes</li> </ul>"},{"location":"mapping-pipeline/#adding-new-qualifiers","title":"Adding new qualifiers","text":"<p>You can add mappings for qualifiers not yet covered by the built-in data:</p> <pre><code>overrides := map[string]any{\n    \"qualifiers\": map[string]any{\n        \"custom_object\": map[string]any{\n            \"request_key_map\":   map[string]any{\"my_attr\": \"MYATTR\"},\n            \"response_key_map\":  map[string]any{\"MYATTR\": \"my_attr\"},\n            \"request_value_map\":  map[string]any{},\n            \"response_value_map\": map[string]any{},\n        },\n    },\n}\n</code></pre>"},{"location":"mapping-pipeline/#validation","title":"Validation","text":"<p>The override structure is validated at session construction time. Invalid shapes cause <code>NewSession</code> to return an error immediately, so problems are caught before any commands are sent.</p>"},{"location":"mapping-pipeline/#per-call-opt-out","title":"Per-call opt-out","text":"<p>Mapping can be disabled entirely at the session level by passing <code>WithMapAttributes(false)</code> when creating the session:</p> <pre><code>// All commands use native MQSC names\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMapAttributes(false),\n)\n\nctx := context.Background()\nqueues, err := session.DisplayQueue(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithResponseParameters([]string{\"CURDEPTH\", \"MAXDEPTH\"}))\n// Returns native MQSC names: [{\"queue\": \"MY.QUEUE\", \"curdepth\": 0, ...}]\n</code></pre> <p>When mapping is disabled, attributes pass through in their native MQSC form.</p>"},{"location":"sync-methods/","title":"Synchronous Start/Stop/Restart","text":""},{"location":"sync-methods/#the-problem-with-fire-and-forget","title":"The problem with fire-and-forget","text":"<p>All MQSC <code>START</code> and <code>STOP</code> commands are fire-and-forget -- they return immediately without waiting for the object to reach its target state. In practice, tooling that provisions infrastructure needs to wait until a channel is <code>RUNNING</code> or a listener is <code>STOPPED</code> before proceeding to the next step. Writing polling loops by hand is error-prone and clutters business logic with retry mechanics.</p>"},{"location":"sync-methods/#the-sync-pattern","title":"The sync pattern","text":"<p>The <code>*Sync</code> and <code>Restart*</code> methods wrap the fire-and-forget commands with a polling loop that issues <code>DISPLAY *STATUS</code> until the object reaches a stable state or the timeout expires.</p> <p>Each call returns a <code>SyncResult</code> describing what happened:</p> <pre><code>// SyncOperation constants:\n//   SyncStarted   -- Object confirmed running\n//   SyncStopped   -- Object confirmed stopped\n//   SyncRestarted -- Stop-then-start completed\n\n// SyncResult struct:\n//   Operation      SyncOperation  -- the operation performed\n//   Polls          int            -- number of status polls issued\n//   ElapsedSeconds float64        -- wall-clock time from command to confirmation\n</code></pre> <p>Polling is controlled by a <code>SyncConfig</code> struct:</p> <pre><code>// SyncConfig struct:\n//   Timeout      time.Duration  -- max wait before returning TimeoutError (default 30s)\n//   PollInterval time.Duration  -- duration between polls (default 1s)\n</code></pre> <p>If the object does not reach the target state within the timeout, a <code>*TimeoutError</code> is returned.</p>"},{"location":"sync-methods/#basic-usage","title":"Basic usage","text":"<pre><code>ctx := context.Background()\n\n// Start a channel and wait until it is RUNNING\nresult, err := session.StartChannelSync(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Channel running after %d poll(s), %.1fs\\n\", result.Polls, result.ElapsedSeconds)\n\n// Stop a listener and wait until it is STOPPED\nresult, err = session.StopListenerSync(ctx, \"TCP.LISTENER\", mqrestadmin.SyncConfig{})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(result.Operation) // \"stopped\"\n</code></pre> <p>Passing a zero-value <code>SyncConfig{}</code> uses the defaults (30-second timeout, 1-second poll interval).</p>"},{"location":"sync-methods/#restart-convenience","title":"Restart convenience","text":"<p>The <code>Restart*</code> methods perform a synchronous stop followed by a synchronous start. Each phase gets the full timeout independently -- worst case is 2x the configured timeout.</p> <p>The returned <code>SyncResult</code> reports total polls and total elapsed time across both phases:</p> <pre><code>ctx := context.Background()\n\nresult, err := session.RestartChannel(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"Restarted in %.1fs (%d total polls)\\n\", result.ElapsedSeconds, result.Polls)\n</code></pre>"},{"location":"sync-methods/#custom-timeout-and-poll-interval","title":"Custom timeout and poll interval","text":"<p>Pass a <code>SyncConfig</code> with non-zero fields to override the defaults:</p> <pre><code>// Aggressive polling for fast local development\nfast := mqrestadmin.SyncConfig{\n    Timeout:      10 * time.Second,\n    PollInterval: 250 * time.Millisecond,\n}\nresult, err := session.StartServiceSync(ctx, \"MY.SVC\", fast)\n\n// Patient polling for remote queue managers\npatient := mqrestadmin.SyncConfig{\n    Timeout:      120 * time.Second,\n    PollInterval: 5 * time.Second,\n}\nresult, err = session.StartChannelSync(ctx, \"REMOTE.CHL\", patient)\n</code></pre>"},{"location":"sync-methods/#timeout-handling","title":"Timeout handling","text":"<p>When the timeout expires, a <code>*TimeoutError</code> is returned with diagnostic fields:</p> <pre><code>result, err := session.StartChannelSync(ctx, \"BROKEN.CHL\", mqrestadmin.SyncConfig{\n    Timeout:      15 * time.Second,\n    PollInterval: 1 * time.Second,\n})\nif err != nil {\n    var timeoutErr *mqrestadmin.TimeoutError\n    if errors.As(err, &amp;timeoutErr) {\n        fmt.Printf(\"Name: %s\\n\", timeoutErr.Name)               // \"BROKEN.CHL\"\n        fmt.Printf(\"Operation: %s\\n\", timeoutErr.Operation)      // \"started\"\n        fmt.Printf(\"Elapsed: %.1fs\\n\", timeoutErr.ElapsedSeconds) // 15.0\n    }\n}\n</code></pre> <p><code>TimeoutError</code> can be matched with <code>errors.As</code>, following standard Go error-handling conventions.</p>"},{"location":"sync-methods/#available-methods","title":"Available methods","text":"Method Operation START/STOP qualifier Status qualifier <code>StartChannelSync()</code> Start <code>CHANNEL</code> <code>CHSTATUS</code> <code>StopChannelSync()</code> Stop <code>CHANNEL</code> <code>CHSTATUS</code> <code>RestartChannel()</code> Restart <code>CHANNEL</code> <code>CHSTATUS</code> <code>StartListenerSync()</code> Start <code>LISTENER</code> <code>LSSTATUS</code> <code>StopListenerSync()</code> Stop <code>LISTENER</code> <code>LSSTATUS</code> <code>RestartListener()</code> Restart <code>LISTENER</code> <code>LSSTATUS</code> <code>StartServiceSync()</code> Start <code>SERVICE</code> <code>SVSTATUS</code> <code>StopServiceSync()</code> Stop <code>SERVICE</code> <code>SVSTATUS</code> <code>RestartService()</code> Restart <code>SERVICE</code> <code>SVSTATUS</code> <p>All methods share the same signature pattern:</p> <pre><code>func (session *Session) StartChannelSync(ctx context.Context, name string, config SyncConfig) (SyncResult, error)\n</code></pre> <p>Every sync method takes <code>context.Context</code> as its first parameter, following standard Go conventions for I/O operations. The <code>config</code> parameter is always required; pass a zero-value <code>SyncConfig{}</code> for defaults.</p>"},{"location":"sync-methods/#status-detection","title":"Status detection","text":"<p>The polling loop checks the <code>STATUS</code> attribute in the <code>DISPLAY *STATUS</code> response. The target values are:</p> <ul> <li>Start: <code>RUNNING</code></li> <li>Stop: <code>STOPPED</code> or <code>INACTIVE</code></li> </ul>"},{"location":"sync-methods/#channel-stop-edge-case","title":"Channel stop edge case","text":"<p>When a channel stops, its <code>CHSTATUS</code> record may disappear entirely (the <code>DISPLAY CHSTATUS</code> response returns no rows). The channel sync methods treat an empty status result as successfully stopped. Listener and service status records are always present, so empty results are not treated as stopped for those object types.</p>"},{"location":"sync-methods/#attribute-mapping","title":"Attribute mapping","text":"<p>The sync methods call the internal MQSC command layer, so they participate in the same mapping pipeline as all other command methods. The status key is checked using both the mapped <code>snake_case</code> name and the raw MQSC name, so polling works correctly regardless of whether mapping is enabled or disabled.</p>"},{"location":"sync-methods/#provisioning-example","title":"Provisioning example","text":"<p>The sync methods pair naturally with the ensure methods for end-to-end provisioning:</p> <pre><code>ctx := context.Background()\nconfig := mqrestadmin.SyncConfig{Timeout: 60 * time.Second}\n\n// Ensure listeners exist for application and admin traffic\n_, err := session.EnsureListener(ctx, \"APP.LISTENER\", map[string]any{\n    \"transport_type\": \"TCP\",\n    \"port\":           1415,\n    \"start_mode\":     \"MQSVC_CONTROL_Q_MGR\",\n})\nif err != nil {\n    log.Fatal(err)\n}\n\n_, err = session.EnsureListener(ctx, \"ADMIN.LISTENER\", map[string]any{\n    \"transport_type\": \"TCP\",\n    \"port\":           1416,\n    \"start_mode\":     \"MQSVC_CONTROL_Q_MGR\",\n})\nif err != nil {\n    log.Fatal(err)\n}\n\n// Start them synchronously\n_, err = session.StartListenerSync(ctx, \"APP.LISTENER\", config)\nif err != nil {\n    log.Fatal(err)\n}\n_, err = session.StartListenerSync(ctx, \"ADMIN.LISTENER\", config)\nif err != nil {\n    log.Fatal(err)\n}\n\nfmt.Println(\"Listeners ready\")\n</code></pre>"},{"location":"sync-methods/#rolling-restart-example","title":"Rolling restart example","text":"<p>Restart all listeners with error handling -- useful when a queue manager serves multiple TCP ports for different client populations:</p> <pre><code>ctx := context.Background()\nlisteners := []string{\"APP.LISTENER\", \"ADMIN.LISTENER\", \"PARTNER.LISTENER\"}\nconfig := mqrestadmin.SyncConfig{\n    Timeout:      30 * time.Second,\n    PollInterval: 2 * time.Second,\n}\n\nfor _, name := range listeners {\n    result, err := session.RestartListener(ctx, name, config)\n    if err != nil {\n        var timeoutErr *mqrestadmin.TimeoutError\n        if errors.As(err, &amp;timeoutErr) {\n            fmt.Printf(\"%s: timed out after %.1fs\\n\", name, timeoutErr.ElapsedSeconds)\n            continue\n        }\n        log.Fatalf(\"%s: %v\", name, err)\n    }\n    fmt.Printf(\"%s: restarted in %.1fs\\n\", name, result.ElapsedSeconds)\n}\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core","title":"Core","text":"<ul> <li>Session -- <code>Session</code> struct and <code>NewSession()</code> constructor</li> <li>Commands -- MQSC command methods</li> <li>Transport -- <code>Transport</code> interface and <code>HTTPTransport</code></li> </ul>"},{"location":"api/#authentication","title":"Authentication","text":"<ul> <li>Auth -- <code>Credentials</code> sealed interface and implementations</li> </ul>"},{"location":"api/#mapping","title":"Mapping","text":"<ul> <li>Mapping -- Attribute mapping pipeline and override modes</li> </ul>"},{"location":"api/#errors","title":"Errors","text":"<ul> <li>Errors -- Error types for <code>errors.As()</code> matching</li> </ul>"},{"location":"api/#patterns","title":"Patterns","text":"<ul> <li>Ensure -- <code>EnsureResult</code>, <code>EnsureAction</code></li> <li>Sync -- <code>SyncConfig</code>, <code>SyncResult</code>, <code>SyncOperation</code></li> </ul>"},{"location":"api/auth/","title":"Authentication","text":""},{"location":"api/auth/#overview","title":"Overview","text":"<p>The authentication module provides credential types for the three authentication modes supported by the IBM MQ REST API: mutual TLS (mTLS) client certificates, LTPA token, and HTTP Basic.</p> <p>Pass a credential value to <code>NewSession</code> as the third argument. Always use TLS (<code>https://</code>) for production deployments to protect credentials and data in transit.</p> <pre><code>import \"github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\"\n\n// mTLS client certificate auth -- strongest; no shared secrets\nsession, err := mqrestadmin.NewSession(\n    \"https://mq-host:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.CertificateAuth{CertPath: \"/path/to/cert.pem\", KeyPath: \"/path/to/key.pem\"},\n)\n\n// LTPA token auth -- credentials sent once at login, then cookie-based\nsession, err := mqrestadmin.NewSession(\n    \"https://mq-host:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"user\", Password: \"pass\"},\n)\n\n// Basic auth -- credentials sent with every request\nsession, err := mqrestadmin.NewSession(\n    \"https://mq-host:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"user\", Password: \"pass\"},\n)\n</code></pre>"},{"location":"api/auth/#credentials","title":"Credentials","text":"<p><code>Credentials</code> is a sealed interface representing authentication credentials for the MQ REST API. The interface is sealed via an unexported method; only <code>BasicAuth</code>, <code>LTPAAuth</code>, and <code>CertificateAuth</code> implement it.</p> <pre><code>type Credentials interface {\n    applyAuth(request *http.Request, session *Session)\n    sealed()\n}\n</code></pre> <p>Because <code>Credentials</code> is sealed, external packages cannot create new implementations. This ensures the session can exhaustively handle all credential types.</p>"},{"location":"api/auth/#certificateauth","title":"CertificateAuth","text":"<p>Client certificate authentication via TLS mutual authentication (mTLS). This is the strongest authentication mode -- no shared secrets cross the wire.</p> <pre><code>type CertificateAuth struct {\n    CertPath string  // path to client certificate PEM file\n    KeyPath  string  // path to private key PEM file (empty if combined)\n}\n</code></pre> <pre><code>// Separate certificate and key files\ncreds := mqrestadmin.CertificateAuth{\n    CertPath: \"/path/to/cert.pem\",\n    KeyPath:  \"/path/to/key.pem\",\n}\n\n// Combined cert+key file (omit KeyPath)\ncreds := mqrestadmin.CertificateAuth{\n    CertPath: \"/path/to/combined.pem\",\n}\n</code></pre> <p>No <code>Authorization</code> header is sent; authentication is handled at the TLS layer. When <code>CertificateAuth</code> is provided and no custom transport is set, <code>NewSession</code> automatically configures the default <code>HTTPTransport</code> with the loaded <code>tls.Certificate</code>.</p>"},{"location":"api/auth/#ltpaauth","title":"LTPAAuth","text":"<p>LTPA token-based authentication. Credentials are sent once during a <code>/login</code> request at session construction; subsequent API calls carry only the LTPA cookie.</p> <pre><code>type LTPAAuth struct {\n    Username string\n    Password string\n}\n</code></pre> <pre><code>creds := mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"passw0rd\"}\n</code></pre> <p>The session performs the login automatically in <code>NewSession</code> and extracts the <code>LtpaToken2</code> cookie for subsequent requests. If the login fails, <code>NewSession</code> returns an <code>*AuthError</code>.</p>"},{"location":"api/auth/#basicauth","title":"BasicAuth","text":"<p>HTTP Basic authentication. The <code>Authorization</code> header is constructed from the username and password and sent with every request.</p> <pre><code>type BasicAuth struct {\n    Username string\n    Password string\n}\n</code></pre> <pre><code>creds := mqrestadmin.BasicAuth{Username: \"mqadmin\", Password: \"passw0rd\"}\n</code></pre> <p>Note</p> <p>All examples and documentation in this project use LTPA as the default authentication method. If you see <code>LTPAAuth{...}</code> in an example, you can substitute <code>BasicAuth{...}</code> or <code>CertificateAuth{...}</code> based on your environment.</p>"},{"location":"api/auth/#choosing-between-ltpa-and-basic-authentication","title":"Choosing between LTPA and Basic authentication","text":"<p>Both LTPA and Basic authentication use a username and password. The key difference is how often those credentials cross the wire.</p> <p>LTPA is the recommended choice for username/password authentication. Credentials are sent once during the <code>/login</code> request; subsequent API calls carry only the LTPA cookie. This reduces credential exposure and is more efficient for sessions that issue many commands.</p> <p>Use Basic authentication as a fallback when:</p> <ul> <li>The mqweb configuration does not enable the <code>/login</code> endpoint (for example,   minimal container images that only expose the REST API).</li> <li>A reverse proxy or API gateway handles authentication and forwards a Basic   auth header; cookie-based flows may not survive the proxy.</li> <li>Single-command scripts where the login round-trip doubles the request count   for no security benefit.</li> <li>Long-running sessions where LTPA token expiry (typically two hours) could   cause mid-operation failures; the library does not currently re-authenticate   automatically.</li> <li>Local development or CI against a <code>localhost</code> container, where transport   security is not a concern.</li> </ul>"},{"location":"api/commands/","title":"Command Methods","text":""},{"location":"api/commands/#overview","title":"Overview","text":"<p><code>Session</code> provides ~144 command methods, one for each MQSC command verb + qualifier combination. Each method is a thin wrapper that calls the internal command dispatcher with the correct verb and qualifier. Method names follow the pattern <code>VerbQualifier</code> in PascalCase, mapping directly to MQSC commands (e.g. <code>DISPLAY QUEUE</code> becomes <code>DisplayQueue()</code>).</p>"},{"location":"api/commands/#method-signature-patterns","title":"Method signature patterns","text":""},{"location":"api/commands/#display-commands-list-return","title":"DISPLAY commands (list return)","text":"<pre><code>func (session *Session) DisplayQueue(\n    ctx  context.Context,\n    name string,\n    opts ...CommandOption,\n) ([]map[string]any, error)\n</code></pre>"},{"location":"api/commands/#display-commands-singleton-return","title":"DISPLAY commands (singleton return)","text":"<p>Queue manager singletons return a single <code>map[string]any</code> instead of a slice:</p> <pre><code>func (session *Session) DisplayQmgr(\n    ctx  context.Context,\n    opts ...CommandOption,\n) (map[string]any, error)\n</code></pre>"},{"location":"api/commands/#non-display-commands-error-only-return","title":"Non-DISPLAY commands (error-only return)","text":"<pre><code>func (session *Session) DefineQlocal(\n    ctx  context.Context,\n    name string,\n    opts ...CommandOption,\n) error\n</code></pre>"},{"location":"api/commands/#commandoption","title":"CommandOption","text":"<p>All command methods accept variadic <code>CommandOption</code> functional options:</p> Option Description <code>WithRequestParameters(map[string]any)</code> MQSC command parameters (attributes to set or filter on) <code>WithResponseParameters([]string)</code> Attribute names to include in the response (defaults to <code>[\"all\"]</code> for DISPLAY) <code>WithWhere(string)</code> WHERE clause to filter DISPLAY command results <pre><code>ctx := context.Background()\n\n// DISPLAY with default options (all attributes, wildcard name)\nqueues, err := session.DisplayQueue(ctx, \"*\")\n\n// DISPLAY with request parameters and response filtering\nqueues, err := session.DisplayQueue(ctx, \"APP.*\",\n    mqrestadmin.WithResponseParameters([]string{\"current_queue_depth\", \"max_queue_depth\"}),\n    mqrestadmin.WithWhere(\"current_queue_depth GT 100\"),\n)\n\n// DEFINE with attributes\nerr = session.DefineQlocal(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithRequestParameters(map[string]any{\n        \"max_queue_depth\": 50000,\n        \"description\":     \"Application request queue\",\n    }),\n)\n\n// DELETE (no options needed)\nerr = session.DeleteQueue(ctx, \"MY.QUEUE\")\n</code></pre>"},{"location":"api/commands/#return-values","title":"Return values","text":"<ul> <li>DISPLAY commands (list): <code>([]map[string]any, error)</code> -- one map per   matched object. A <code>nil</code> or empty slice means no objects matched (not an error).</li> <li>Queue manager singletons (<code>DisplayQmgr</code>, <code>DisplayQmstatus</code>,   <code>DisplayCmdserv</code>): <code>(map[string]any, error)</code> -- returns <code>nil</code> map if empty.</li> <li>Non-DISPLAY commands: <code>error</code> on failure, <code>nil</code> on success.</li> </ul>"},{"location":"api/commands/#display-methods","title":"DISPLAY methods","text":"Method MQSC command Qualifier mapping <code>DisplayApstatus()</code> <code>DISPLAY APSTATUS</code> apstatus <code>DisplayArchive()</code> <code>DISPLAY ARCHIVE</code> archive <code>DisplayAuthinfo()</code> <code>DISPLAY AUTHINFO</code> authinfo <code>DisplayAuthrec()</code> <code>DISPLAY AUTHREC</code> authrec <code>DisplayAuthserv()</code> <code>DISPLAY AUTHSERV</code> authserv <code>DisplayCfstatus()</code> <code>DISPLAY CFSTATUS</code> cfstatus <code>DisplayCfstruct()</code> <code>DISPLAY CFSTRUCT</code> cfstruct <code>DisplayChannel()</code> <code>DISPLAY CHANNEL</code> channel <code>DisplayChinit()</code> <code>DISPLAY CHINIT</code> chinit <code>DisplayChlauth()</code> <code>DISPLAY CHLAUTH</code> chlauth <code>DisplayChstatus()</code> <code>DISPLAY CHSTATUS</code> chstatus <code>DisplayClusqmgr()</code> <code>DISPLAY CLUSQMGR</code> clusqmgr <code>DisplayCmdserv()</code> <code>DISPLAY CMDSERV</code> cmdserv <code>DisplayComminfo()</code> <code>DISPLAY COMMINFO</code> comminfo <code>DisplayConn()</code> <code>DISPLAY CONN</code> conn <code>DisplayEntauth()</code> <code>DISPLAY ENTAUTH</code> entauth <code>DisplayGroup()</code> <code>DISPLAY GROUP</code> group <code>DisplayListener()</code> <code>DISPLAY LISTENER</code> listener <code>DisplayLog()</code> <code>DISPLAY LOG</code> log <code>DisplayLsstatus()</code> <code>DISPLAY LSSTATUS</code> lsstatus <code>DisplayMaxsmsgs()</code> <code>DISPLAY MAXSMSGS</code> maxsmsgs <code>DisplayNamelist()</code> <code>DISPLAY NAMELIST</code> namelist <code>DisplayPolicy()</code> <code>DISPLAY POLICY</code> policy <code>DisplayProcess()</code> <code>DISPLAY PROCESS</code> process <code>DisplayPubsub()</code> <code>DISPLAY PUBSUB</code> pubsub <code>DisplayQmgr()</code> <code>DISPLAY QMGR</code> qmgr <code>DisplayQmstatus()</code> <code>DISPLAY QMSTATUS</code> qmgr <code>DisplayQstatus()</code> <code>DISPLAY QSTATUS</code> qstatus <code>DisplayQueue()</code> <code>DISPLAY QUEUE</code> queue <code>DisplaySbstatus()</code> <code>DISPLAY SBSTATUS</code> sbstatus <code>DisplaySecurity()</code> <code>DISPLAY SECURITY</code> security <code>DisplayService()</code> <code>DISPLAY SERVICE</code> service <code>DisplaySmds()</code> <code>DISPLAY SMDS</code> smds <code>DisplaySmdsconn()</code> <code>DISPLAY SMDSCONN</code> smdsconn <code>DisplayStgclass()</code> <code>DISPLAY STGCLASS</code> stgclass <code>DisplaySub()</code> <code>DISPLAY SUB</code> sub <code>DisplaySvstatus()</code> <code>DISPLAY SVSTATUS</code> svstatus <code>DisplaySystem()</code> <code>DISPLAY SYSTEM</code> system <code>DisplayTcluster()</code> <code>DISPLAY TCLUSTER</code> tcluster <code>DisplayThread()</code> <code>DISPLAY THREAD</code> thread <code>DisplayTopic()</code> <code>DISPLAY TOPIC</code> topic <code>DisplayTpstatus()</code> <code>DISPLAY TPSTATUS</code> tpstatus <code>DisplayTrace()</code> <code>DISPLAY TRACE</code> trace <code>DisplayUsage()</code> <code>DISPLAY USAGE</code> usage"},{"location":"api/commands/#define-methods","title":"DEFINE methods","text":"Method MQSC command Qualifier mapping <code>DefineAuthinfo()</code> <code>DEFINE AUTHINFO</code> authinfo <code>DefineBuffpool()</code> <code>DEFINE BUFFPOOL</code> buffpool <code>DefineCfstruct()</code> <code>DEFINE CFSTRUCT</code> cfstruct <code>DefineChannel()</code> <code>DEFINE CHANNEL</code> channel <code>DefineComminfo()</code> <code>DEFINE COMMINFO</code> comminfo <code>DefineListener()</code> <code>DEFINE LISTENER</code> listener <code>DefineLog()</code> <code>DEFINE LOG</code> log <code>DefineMaxsmsgs()</code> <code>DEFINE MAXSMSGS</code> maxsmsgs <code>DefineNamelist()</code> <code>DEFINE NAMELIST</code> namelist <code>DefineProcess()</code> <code>DEFINE PROCESS</code> process <code>DefinePsid()</code> <code>DEFINE PSID</code> psid <code>DefineQalias()</code> <code>DEFINE QALIAS</code> queue <code>DefineQlocal()</code> <code>DEFINE QLOCAL</code> queue <code>DefineQmodel()</code> <code>DEFINE QMODEL</code> queue <code>DefineQremote()</code> <code>DEFINE QREMOTE</code> queue <code>DefineService()</code> <code>DEFINE SERVICE</code> service <code>DefineStgclass()</code> <code>DEFINE STGCLASS</code> stgclass <code>DefineSub()</code> <code>DEFINE SUB</code> sub <code>DefineTopic()</code> <code>DEFINE TOPIC</code> topic"},{"location":"api/commands/#delete-methods","title":"DELETE methods","text":"Method MQSC command Qualifier mapping <code>DeleteAuthinfo()</code> <code>DELETE AUTHINFO</code> authinfo <code>DeleteAuthrec()</code> <code>DELETE AUTHREC</code> authrec <code>DeleteBuffpool()</code> <code>DELETE BUFFPOOL</code> buffpool <code>DeleteCfstruct()</code> <code>DELETE CFSTRUCT</code> cfstruct <code>DeleteChannel()</code> <code>DELETE CHANNEL</code> channel <code>DeleteComminfo()</code> <code>DELETE COMMINFO</code> comminfo <code>DeleteListener()</code> <code>DELETE LISTENER</code> listener <code>DeleteNamelist()</code> <code>DELETE NAMELIST</code> namelist <code>DeletePolicy()</code> <code>DELETE POLICY</code> policy <code>DeleteProcess()</code> <code>DELETE PROCESS</code> process <code>DeletePsid()</code> <code>DELETE PSID</code> psid <code>DeleteQueue()</code> <code>DELETE QUEUE</code> queue <code>DeleteService()</code> <code>DELETE SERVICE</code> service <code>DeleteStgclass()</code> <code>DELETE STGCLASS</code> stgclass <code>DeleteSub()</code> <code>DELETE SUB</code> sub <code>DeleteTopic()</code> <code>DELETE TOPIC</code> topic"},{"location":"api/commands/#alter-methods","title":"ALTER methods","text":"Method MQSC command Qualifier mapping <code>AlterAuthinfo()</code> <code>ALTER AUTHINFO</code> authinfo <code>AlterBuffpool()</code> <code>ALTER BUFFPOOL</code> buffpool <code>AlterCfstruct()</code> <code>ALTER CFSTRUCT</code> cfstruct <code>AlterChannel()</code> <code>ALTER CHANNEL</code> channel <code>AlterComminfo()</code> <code>ALTER COMMINFO</code> comminfo <code>AlterListener()</code> <code>ALTER LISTENER</code> listener <code>AlterNamelist()</code> <code>ALTER NAMELIST</code> namelist <code>AlterProcess()</code> <code>ALTER PROCESS</code> process <code>AlterPsid()</code> <code>ALTER PSID</code> psid <code>AlterQmgr()</code> <code>ALTER QMGR</code> qmgr <code>AlterSecurity()</code> <code>ALTER SECURITY</code> security <code>AlterService()</code> <code>ALTER SERVICE</code> service <code>AlterSmds()</code> <code>ALTER SMDS</code> smds <code>AlterStgclass()</code> <code>ALTER STGCLASS</code> stgclass <code>AlterSub()</code> <code>ALTER SUB</code> sub <code>AlterTopic()</code> <code>ALTER TOPIC</code> topic <code>AlterTrace()</code> <code>ALTER TRACE</code> trace"},{"location":"api/commands/#set-methods","title":"SET methods","text":"Method MQSC command Qualifier mapping <code>SetArchive()</code> <code>SET ARCHIVE</code> archive <code>SetAuthrec()</code> <code>SET AUTHREC</code> authrec <code>SetChlauth()</code> <code>SET CHLAUTH</code> chlauth <code>SetLog()</code> <code>SET LOG</code> log <code>SetPolicy()</code> <code>SET POLICY</code> policy <code>SetSystem()</code> <code>SET SYSTEM</code> system"},{"location":"api/commands/#start-methods","title":"START methods","text":"Method MQSC command Qualifier mapping <code>StartChannel()</code> <code>START CHANNEL</code> channel <code>StartChinit()</code> <code>START CHINIT</code> chinit <code>StartCmdserv()</code> <code>START CMDSERV</code> cmdserv <code>StartListener()</code> <code>START LISTENER</code> listener <code>StartQmgr()</code> <code>START QMGR</code> qmgr <code>StartService()</code> <code>START SERVICE</code> service <code>StartSmdsconn()</code> <code>START SMDSCONN</code> smdsconn <code>StartTrace()</code> <code>START TRACE</code> trace"},{"location":"api/commands/#stop-methods","title":"STOP methods","text":"Method MQSC command Qualifier mapping <code>StopChannel()</code> <code>STOP CHANNEL</code> channel <code>StopChinit()</code> <code>STOP CHINIT</code> chinit <code>StopCmdserv()</code> <code>STOP CMDSERV</code> cmdserv <code>StopConn()</code> <code>STOP CONN</code> conn <code>StopListener()</code> <code>STOP LISTENER</code> listener <code>StopQmgr()</code> <code>STOP QMGR</code> qmgr <code>StopService()</code> <code>STOP SERVICE</code> service <code>StopSmdsconn()</code> <code>STOP SMDSCONN</code> smdsconn <code>StopTrace()</code> <code>STOP TRACE</code> trace"},{"location":"api/commands/#other-methods","title":"Other methods","text":"Method MQSC command Qualifier mapping <code>ArchiveLog()</code> <code>ARCHIVE LOG</code> log <code>BackupCfstruct()</code> <code>BACKUP CFSTRUCT</code> cfstruct <code>ClearQlocal()</code> <code>CLEAR QLOCAL</code> queue <code>ClearTopicstr()</code> <code>CLEAR TOPICSTR</code> topicstr <code>MoveQlocal()</code> <code>MOVE QLOCAL</code> queue <code>PingChannel()</code> <code>PING CHANNEL</code> channel <code>PingQmgr()</code> <code>PING QMGR</code> qmgr <code>PurgeChannel()</code> <code>PURGE CHANNEL</code> channel <code>RecoverBsds()</code> <code>RECOVER BSDS</code> bsds <code>RecoverCfstruct()</code> <code>RECOVER CFSTRUCT</code> cfstruct <code>RefreshCluster()</code> <code>REFRESH CLUSTER</code> cluster <code>RefreshQmgr()</code> <code>REFRESH QMGR</code> qmgr <code>RefreshSecurity()</code> <code>REFRESH SECURITY</code> security <code>ResetCfstruct()</code> <code>RESET CFSTRUCT</code> cfstruct <code>ResetChannel()</code> <code>RESET CHANNEL</code> channel <code>ResetCluster()</code> <code>RESET CLUSTER</code> cluster <code>ResetQmgr()</code> <code>RESET QMGR</code> qmgr <code>ResetQstats()</code> <code>RESET QSTATS</code> queue <code>ResetSmds()</code> <code>RESET SMDS</code> smds <code>ResetTpipe()</code> <code>RESET TPIPE</code> tpipe <code>ResolveChannel()</code> <code>RESOLVE CHANNEL</code> channel <code>ResolveIndoubt()</code> <code>RESOLVE INDOUBT</code> indoubt <code>ResumeQmgr()</code> <code>RESUME QMGR</code> qmgr <code>RverifySecurity()</code> <code>RVERIFY SECURITY</code> security <code>SuspendQmgr()</code> <code>SUSPEND QMGR</code> qmgr <p>Note</p> <p>The full list of command methods is generated from the mapping data. See the Qualifier Mapping Reference for per-qualifier details including attribute names and value mappings for each object type.</p>"},{"location":"api/ensure/","title":"Ensure","text":""},{"location":"api/ensure/#overview","title":"Overview","text":"<p>The ensure methods provide 16 idempotent ensure operations on <code>Session</code>. These methods implement a declarative upsert pattern: DEFINE if the object does not exist, ALTER only attributes that differ, or no-op if the object already matches the desired state.</p>"},{"location":"api/ensure/#ensureaction","title":"EnsureAction","text":"<p>An integer enum indicating the action taken by an ensure method:</p> <pre><code>const (\n    EnsureCreated   EnsureAction = iota  // Object did not exist; DEFINE was issued\n    EnsureUpdated                        // Object existed but attributes differed; ALTER was issued\n    EnsureUnchanged                      // Object already matched the desired state\n)\n</code></pre> <p><code>EnsureAction</code> implements <code>fmt.Stringer</code>, returning <code>\"created\"</code>, <code>\"updated\"</code>, or <code>\"unchanged\"</code>.</p>"},{"location":"api/ensure/#ensureresult","title":"EnsureResult","text":"<p>A struct containing the action taken and the list of attribute names that triggered the change (if any):</p> <pre><code>type EnsureResult struct {\n    Action  EnsureAction  // What happened: EnsureCreated, EnsureUpdated, or EnsureUnchanged\n    Changed []string      // Attribute names that triggered an ALTER (in the caller's namespace)\n}\n</code></pre> Field Type Description <code>Action</code> <code>EnsureAction</code> What happened: <code>EnsureCreated</code>, <code>EnsureUpdated</code>, or <code>EnsureUnchanged</code> <code>Changed</code> <code>[]string</code> Attribute names that triggered an ALTER (in the caller's namespace)"},{"location":"api/ensure/#method-signature-patterns","title":"Method signature patterns","text":"<p>Named-object ensure methods share this signature:</p> <pre><code>func (session *Session) EnsureQlocal(\n    ctx               context.Context,\n    name              string,\n    requestParameters map[string]any,\n) (EnsureResult, error)\n</code></pre> <p>The queue manager ensure method omits the name parameter:</p> <pre><code>func (session *Session) EnsureQmgr(\n    ctx               context.Context,\n    requestParameters map[string]any,\n) (EnsureResult, error)\n</code></pre>"},{"location":"api/ensure/#available-ensure-methods","title":"Available ensure methods","text":"Method Object type <code>EnsureQmgr()</code> Queue manager (always exists; never returns <code>EnsureCreated</code>) <code>EnsureQlocal()</code> Local queue <code>EnsureQremote()</code> Remote queue <code>EnsureQalias()</code> Alias queue <code>EnsureQmodel()</code> Model queue <code>EnsureChannel()</code> Channel <code>EnsureAuthinfo()</code> Authentication information object <code>EnsureListener()</code> Listener <code>EnsureNamelist()</code> Namelist <code>EnsureProcess()</code> Process <code>EnsureService()</code> Service <code>EnsureTopic()</code> Topic <code>EnsureSub()</code> Subscription <code>EnsureStgclass()</code> Storage class <code>EnsureComminfo()</code> Communication information object <code>EnsureCfstruct()</code> CF structure"},{"location":"api/ensure/#usage","title":"Usage","text":"<pre><code>ctx := context.Background()\n\nresult, err := session.EnsureQlocal(ctx, \"MY.QUEUE\",\n    map[string]any{\n        \"max_queue_depth\": 50000,\n        \"description\":     \"App queue\",\n    })\nif err != nil {\n    log.Fatal(err)\n}\n\nswitch result.Action {\ncase mqrestadmin.EnsureCreated:\n    fmt.Println(\"Queue created\")\ncase mqrestadmin.EnsureUpdated:\n    fmt.Println(\"Changed:\", result.Changed)\ncase mqrestadmin.EnsureUnchanged:\n    fmt.Println(\"Already correct\")\n}\n</code></pre>"},{"location":"api/ensure/#how-comparison-works","title":"How comparison works","text":"<p>The ensure methods compare desired attributes against the current state using case-insensitive string comparison after trimming whitespace. Only attributes that differ are included in the ALTER command. Attributes not specified in the request are left unchanged.</p> <p>See Ensure Methods for the full conceptual overview and comparison logic.</p>"},{"location":"api/errors/","title":"Errors","text":""},{"location":"api/errors/#overview","title":"Overview","text":"<p>All error types are concrete structs that implement the <code>error</code> interface. They are designed for use with Go's <code>errors.As()</code> for targeted error handling. Unlike Java's sealed exception hierarchy, Go errors are matched structurally using type assertions or <code>errors.As()</code>.</p> <pre><code>*TransportError   -- Network/connection failures\n*ResponseError    -- Malformed JSON, unexpected structure\n*AuthError        -- Authentication/authorization failures\n*CommandError     -- MQSC command returned error codes\n*TimeoutError     -- Polling timeout exceeded\n*MappingError     -- Attribute mapping failures (separate concern)\n</code></pre>"},{"location":"api/errors/#transporterror","title":"TransportError","text":"<p>Returned when the HTTP request fails at the network level -- connection refused, DNS resolution failure, TLS handshake error, etc. Wraps the underlying error via <code>Unwrap()</code>.</p> <pre><code>type TransportError struct {\n    URL string  // The URL that was being accessed\n    Err error   // The underlying error\n}\n</code></pre> Field Type Description <code>URL</code> <code>string</code> The URL that was being accessed <code>Err</code> <code>error</code> The underlying network error <p><code>TransportError</code> implements <code>Unwrap() error</code>, so you can inspect the root cause with <code>errors.Unwrap()</code> or match nested errors with <code>errors.Is()</code>.</p> <pre><code>queues, err := session.DisplayQueue(ctx, \"*\")\nif err != nil {\n    var transportErr *mqrestadmin.TransportError\n    if errors.As(err, &amp;transportErr) {\n        fmt.Println(\"Cannot reach:\", transportErr.URL)\n        fmt.Println(\"Cause:\", transportErr.Err)\n    }\n}\n</code></pre>"},{"location":"api/errors/#responseerror","title":"ResponseError","text":"<p>Returned when the HTTP request succeeds but the response cannot be parsed -- invalid JSON, missing expected fields, unexpected response structure.</p> <pre><code>type ResponseError struct {\n    ResponseText string  // Raw response body\n    StatusCode   int     // HTTP status code\n}\n</code></pre> Field Type Description <code>ResponseText</code> <code>string</code> Raw response body <code>StatusCode</code> <code>int</code> HTTP status code <pre><code>queues, err := session.DisplayQueue(ctx, \"*\")\nif err != nil {\n    var responseErr *mqrestadmin.ResponseError\n    if errors.As(err, &amp;responseErr) {\n        fmt.Printf(\"Bad response (HTTP %d): %s\\n\",\n            responseErr.StatusCode, responseErr.ResponseText)\n    }\n}\n</code></pre>"},{"location":"api/errors/#autherror","title":"AuthError","text":"<p>Returned when authentication or authorization fails -- invalid credentials, expired tokens, insufficient permissions (HTTP 401/403), or LTPA login failure.</p> <pre><code>type AuthError struct {\n    URL        string  // The URL that was being accessed\n    StatusCode int     // HTTP status code\n}\n</code></pre> Field Type Description <code>URL</code> <code>string</code> The URL that was being accessed <code>StatusCode</code> <code>int</code> HTTP status code (401 or 403) <pre><code>qmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    var authErr *mqrestadmin.AuthError\n    if errors.As(err, &amp;authErr) {\n        fmt.Printf(\"Auth failed: HTTP %d for %s\\n\",\n            authErr.StatusCode, authErr.URL)\n    }\n}\n</code></pre>"},{"location":"api/errors/#commanderror","title":"CommandError","text":"<p>Returned when the MQSC command returns a non-zero completion or reason code. This is the most commonly encountered error -- it indicates the command was delivered to MQ but the queue manager rejected it.</p> <pre><code>type CommandError struct {\n    Payload    map[string]any  // Full response payload\n    StatusCode int             // HTTP status code\n}\n</code></pre> Field Type Description <code>Payload</code> <code>map[string]any</code> Full response payload including completion and reason codes <code>StatusCode</code> <code>int</code> HTTP status code <pre><code>err := session.DefineQlocal(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithRequestParameters(map[string]any{}))\nif err != nil {\n    var cmdErr *mqrestadmin.CommandError\n    if errors.As(err, &amp;cmdErr) {\n        fmt.Println(\"Command failed:\", cmdErr.Error())\n        fmt.Println(\"HTTP status:\", cmdErr.StatusCode)\n        fmt.Println(\"Response:\", cmdErr.Payload)\n    }\n}\n</code></pre>"},{"location":"api/errors/#timeouterror","title":"TimeoutError","text":"<p>Returned when a synchronous polling operation exceeds its configured timeout duration. Only produced by sync methods.</p> <pre><code>type TimeoutError struct {\n    Name           string         // Resource name being polled\n    Operation      SyncOperation  // Operation being performed\n    ElapsedSeconds float64        // Elapsed time in seconds\n}\n</code></pre> Field Type Description <code>Name</code> <code>string</code> Resource name being polled <code>Operation</code> <code>SyncOperation</code> The sync operation (<code>SyncStarted</code>, <code>SyncStopped</code>) <code>ElapsedSeconds</code> <code>float64</code> Elapsed time in seconds <pre><code>result, err := session.StartChannelSync(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{\n    Timeout: 5 * time.Second,\n})\nif err != nil {\n    var timeoutErr *mqrestadmin.TimeoutError\n    if errors.As(err, &amp;timeoutErr) {\n        fmt.Printf(\"Timed out %s %s after %.1fs\\n\",\n            timeoutErr.Operation, timeoutErr.Name, timeoutErr.ElapsedSeconds)\n    }\n}\n</code></pre>"},{"location":"api/errors/#mappingerror","title":"MappingError","text":"<p>Returned when attribute mapping fails in strict mode. Separate from the transport/command error types. Contains the list of <code>MappingIssue</code> instances that caused the failure.</p> <pre><code>type MappingError struct {\n    Issues []MappingIssue\n}\n</code></pre> Field Type Description <code>Issues</code> <code>[]MappingIssue</code> List of attribute translation failures <p>See Mapping for details on <code>MappingIssue</code>, <code>MappingDirection</code>, and <code>MappingReason</code>.</p> <pre><code>queues, err := session.DisplayQueue(ctx, \"*\",\n    mqrestadmin.WithRequestParameters(map[string]any{\n        \"invalid_attr\": \"value\",\n    }),\n)\nif err != nil {\n    var mappingErr *mqrestadmin.MappingError\n    if errors.As(err, &amp;mappingErr) {\n        for _, issue := range mappingErr.Issues {\n            fmt.Printf(\"%s %s: %s\\n\",\n                issue.Direction, issue.Reason, issue.AttributeName)\n        }\n    }\n}\n</code></pre>"},{"location":"api/errors/#error-handling-patterns","title":"Error handling patterns","text":"<p>Use <code>errors.As()</code> for targeted recovery, or check the error interface for broad handling:</p> <pre><code>err := session.DefineQlocal(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithRequestParameters(map[string]any{\"max_queue_depth\": 50000}))\nif err != nil {\n    var cmdErr *mqrestadmin.CommandError\n    var authErr *mqrestadmin.AuthError\n    var transportErr *mqrestadmin.TransportError\n    var mappingErr *mqrestadmin.MappingError\n\n    switch {\n    case errors.As(err, &amp;cmdErr):\n        // MQSC command failed -- check reason code in payload\n        fmt.Println(\"Command failed:\", cmdErr.Error())\n    case errors.As(err, &amp;authErr):\n        // Credentials rejected\n        fmt.Printf(\"Not authorized: HTTP %d\\n\", authErr.StatusCode)\n    case errors.As(err, &amp;transportErr):\n        // Network error\n        fmt.Println(\"Connection failed to\", transportErr.URL)\n    case errors.As(err, &amp;mappingErr):\n        // Attribute name/value not recognized\n        fmt.Println(\"Mapping failed:\", mappingErr.Error())\n    default:\n        // Catch-all\n        fmt.Println(\"Unexpected error:\", err)\n    }\n}\n</code></pre>"},{"location":"api/mapping/","title":"Mapping","text":""},{"location":"api/mapping/#overview","title":"Overview","text":"<p>The mapping module provides bidirectional attribute translation between developer-friendly <code>snake_case</code> names and native MQSC parameter names. The mapper is created internally by <code>Session</code> and is not typically used directly.</p> <p>See Mapping Pipeline for a conceptual overview of how mapping works.</p>"},{"location":"api/mapping/#attribute-mapping","title":"Attribute mapping","text":"<p>The internal <code>attributeMapper</code> translates attribute names and values between the developer-friendly namespace and the MQSC namespace. The mapper performs three types of translation in each direction:</p> <ul> <li>Key mapping: Attribute name translation (e.g. <code>current_queue_depth</code> to   <code>CURDEPTH</code>)</li> <li>Value mapping: Enumerated value translation (e.g. <code>\"yes\"</code> to <code>\"YES\"</code>,   <code>\"server_connection\"</code> to <code>\"SVRCONN\"</code>)</li> <li>Key-value mapping: Combined name+value translation for cases where both   key and value change together (e.g. <code>channel_type=\"server_connection\"</code> to   <code>CHLTYPE(\"SVRCONN\")</code>)</li> </ul> <p>The mapper is qualifier-aware: it selects the correct mapping tables based on the MQSC command's qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>).</p>"},{"location":"api/mapping/#controlling-mapping","title":"Controlling mapping","text":""},{"location":"api/mapping/#withmapattributes","title":"WithMapAttributes","text":"<p>Controls whether attribute names are translated. Defaults to <code>true</code>.</p> <pre><code>// Disable mapping -- use raw MQSC parameter names\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMapAttributes(false),\n)\n\n// With mapping disabled, use MQSC names directly\nqueues, err := session.DisplayQueue(ctx, \"*\",\n    mqrestadmin.WithRequestParameters(map[string]any{\"CURDEPTH\": 0}),\n)\n</code></pre>"},{"location":"api/mapping/#withmappingstrict","title":"WithMappingStrict","text":"<p>Controls whether unknown attributes cause an error or pass through silently. Defaults to <code>true</code> (strict mode).</p> <pre><code>// Permissive mode -- unknown attributes pass through without error\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMappingStrict(false),\n)\n</code></pre> <p>Strict mode (default): Any attribute name or value that cannot be mapped causes a <code>*MappingError</code> to be returned. This catches typos and ensures all attributes are correctly translated.</p> <p>Permissive mode: Unknown attributes pass through unchanged. A <code>*MappingError</code> is not returned, but <code>MappingIssue</code> values are still tracked internally. This is useful when working with custom or version-specific attributes not covered by the built-in mapping data.</p>"},{"location":"api/mapping/#mappingoverridemode","title":"MappingOverrideMode","text":"<p>Controls how custom overrides are merged with built-in mapping data:</p> <pre><code>const (\n    MappingOverrideMerge   MappingOverrideMode = iota  // overlay at key level\n    MappingOverrideReplace                             // replace entire qualifier section\n)\n</code></pre> <ul> <li>MappingOverrideMerge (default): Override entries are merged at the key   level within each sub-map. Existing entries not mentioned in the override are   preserved. This is the common case for changing a few attribute names without   losing the rest.</li> <li>MappingOverrideReplace: The override completely replaces the specified   qualifier section. Use when you need full control over a qualifier's mapping.</li> </ul> <pre><code>overrides := map[string]any{\n    \"qualifiers\": map[string]any{\n        \"queue\": map[string]any{\n            \"request_key_map\": map[string]string{\n                \"my_custom_attr\": \"MYCUSTOM\",\n            },\n        },\n    },\n}\n\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\", \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithMappingOverrides(overrides, mqrestadmin.MappingOverrideMerge),\n)\n</code></pre>"},{"location":"api/mapping/#mapping-data","title":"Mapping data","text":"<p>The mapping definitions are embedded in the compiled binary from <code>mapping-data.json</code> using Go's <code>//go:embed</code> directive. The data is organized by qualifier (e.g. <code>queue</code>, <code>channel</code>, <code>qmgr</code>) with separate maps for request and response directions. Each qualifier contains:</p> <ul> <li><code>request_key_map</code> -- developer-friendly to MQSC key mapping for requests</li> <li><code>request_value_map</code> -- value translations for request attributes</li> <li><code>request_key_value_map</code> -- combined key+value translations for requests</li> <li><code>response_key_map</code> -- MQSC to developer-friendly key mapping for responses</li> <li><code>response_value_map</code> -- value translations for response attributes</li> </ul> <p>The mapping data was originally bootstrapped from IBM MQ 9.4 documentation and covers all standard MQSC attributes across 42 qualifiers.</p>"},{"location":"api/mapping/#mappingissue","title":"MappingIssue","text":"<p>Tracks mapping problems encountered during translation:</p> <pre><code>type MappingIssue struct {\n    Direction      MappingDirection  // MappingRequest or MappingResponse\n    Reason         MappingReason     // MappingUnknownKey, MappingUnknownValue, or MappingUnknownQualifier\n    AttributeName  string            // The attribute that failed translation\n    AttributeValue any               // The value that failed translation (if applicable)\n    ObjectIndex    *int              // Index within a response list (if applicable)\n    Qualifier      string            // The mapping qualifier (if applicable)\n}\n</code></pre>"},{"location":"api/mapping/#mappingdirection","title":"MappingDirection","text":"<pre><code>const (\n    MappingRequest  MappingDirection = iota  // Failure during request translation\n    MappingResponse                          // Failure during response translation\n)\n</code></pre>"},{"location":"api/mapping/#mappingreason","title":"MappingReason","text":"<pre><code>const (\n    MappingUnknownKey       MappingReason = iota  // Unrecognized attribute name\n    MappingUnknownValue                           // Unrecognized attribute value\n    MappingUnknownQualifier                       // Unrecognized qualifier\n)\n</code></pre>"},{"location":"api/mapping/#mappingerror","title":"MappingError","text":"<p>Returned when attribute mapping fails in strict mode. Separate from the main error types (it does not wrap any of the transport/command error types). Contains the list of <code>MappingIssue</code> instances that caused the failure.</p> <pre><code>type MappingError struct {\n    Issues []MappingIssue\n}\n</code></pre> <pre><code>queues, err := session.DisplayQueue(ctx, \"*\",\n    mqrestadmin.WithRequestParameters(map[string]any{\n        \"invalid_attribute_name\": \"value\",\n    }),\n)\nif err != nil {\n    var mappingErr *mqrestadmin.MappingError\n    if errors.As(err, &amp;mappingErr) {\n        for _, issue := range mappingErr.Issues {\n            fmt.Printf(\"Mapping issue: %s %s: %s\\n\",\n                issue.Direction, issue.Reason, issue.AttributeName)\n        }\n    }\n}\n</code></pre> <p>See Errors for the complete error type reference.</p>"},{"location":"api/session/","title":"Session","text":""},{"location":"api/session/#overview","title":"Overview","text":"<p>The main entry point for interacting with an IBM MQ queue manager's administrative REST API. A <code>Session</code> encapsulates connection details, authentication, attribute mapping configuration, and diagnostic state. It provides ~144 command methods covering all MQSC verbs and qualifiers, plus 16 idempotent ensure methods and 9 synchronous sync methods.</p> <p>The Go implementation uses functional options for construction, following standard Go library conventions.</p>"},{"location":"api/session/#creating-a-session","title":"Creating a session","text":"<p>Use <code>NewSession</code> with functional options:</p> <pre><code>import \"github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\"\n\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n)\n</code></pre> <p><code>NewSession</code> validates configuration, initializes the attribute mapper, and (for LTPA credentials) performs the login request immediately. Errors in configuration are returned at construction time.</p>"},{"location":"api/session/#signature","title":"Signature","text":"<pre><code>func NewSession(\n    restBaseURL string,\n    qmgrName    string,\n    credentials Credentials,\n    opts        ...Option,\n) (*Session, error)\n</code></pre> Parameter Description <code>restBaseURL</code> Base URL of the MQ REST API (e.g. <code>https://host:9443/ibmmq/rest/v2</code>) <code>qmgrName</code> Target queue manager name <code>credentials</code> Authentication credentials (<code>BasicAuth</code>, <code>LTPAAuth</code>, or <code>CertificateAuth</code>) <code>opts</code> Zero or more functional options"},{"location":"api/session/#functional-options","title":"Functional options","text":"Option Type Description <code>WithTransport(Transport)</code> <code>Transport</code> Custom transport implementation (default: <code>HTTPTransport</code>) <code>WithGatewayQmgr(string)</code> <code>string</code> Gateway queue manager for remote routing <code>WithVerifyTLS(bool)</code> <code>bool</code> Verify server TLS certificates (default: <code>true</code>) <code>WithTimeout(time.Duration)</code> <code>time.Duration</code> HTTP request timeout (default: 30s) <code>WithMapAttributes(bool)</code> <code>bool</code> Enable/disable attribute mapping (default: <code>true</code>) <code>WithMappingStrict(bool)</code> <code>bool</code> Strict or permissive mapping mode (default: <code>true</code>) <code>WithCSRFToken(*string)</code> <code>*string</code> Custom CSRF token value; <code>nil</code> omits the header <code>WithMappingOverrides(map[string]any, MappingOverrideMode)</code> <code>map[string]any</code> Custom mapping overrides with merge or replace mode"},{"location":"api/session/#minimal-example","title":"Minimal example","text":"<pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"api/session/#full-example","title":"Full example","text":"<pre><code>session, err := mqrestadmin.NewSession(\n    \"https://mq-server.example.com:9443/ibmmq/rest/v2\",\n    \"QM2\",\n    mqrestadmin.BasicAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithGatewayQmgr(\"QM1\"),\n    mqrestadmin.WithMapAttributes(true),\n    mqrestadmin.WithMappingStrict(false),\n    mqrestadmin.WithVerifyTLS(true),\n    mqrestadmin.WithTimeout(30*time.Second),\n    mqrestadmin.WithMappingOverrides(overrides, mqrestadmin.MappingOverrideMerge),\n)\nif err != nil {\n    log.Fatal(err)\n}\n</code></pre>"},{"location":"api/session/#command-methods","title":"Command methods","text":"<p>The session provides ~144 command methods, one for each MQSC verb + qualifier combination. See Commands for the full list.</p> <pre><code>ctx := context.Background()\n\n// DISPLAY commands return a slice of maps\nqueues, err := session.DisplayQueue(ctx, \"APP.*\")\n\n// Queue manager singletons return a single map\nqmgr, err := session.DisplayQmgr(ctx)\n\n// Non-DISPLAY commands return only an error\nerr = session.DefineQlocal(ctx, \"MY.QUEUE\",\n    mqrestadmin.WithRequestParameters(map[string]any{\"max_queue_depth\": 50000}))\nerr = session.DeleteQueue(ctx, \"MY.QUEUE\")\n</code></pre>"},{"location":"api/session/#ensure-methods","title":"Ensure methods","text":"<p>The session provides 16 ensure methods for declarative object management. Each method implements an idempotent upsert: DEFINE if the object does not exist, ALTER only the attributes that differ, or no-op if already correct.</p> <pre><code>result, err := session.EnsureQlocal(ctx, \"MY.QUEUE\",\n    map[string]any{\"max_queue_depth\": 50000})\n// result.Action is EnsureCreated, EnsureUpdated, or EnsureUnchanged\n</code></pre> <p>See Ensure for details.</p>"},{"location":"api/session/#diagnostic-fields","title":"Diagnostic fields","text":"<p>The session retains the most recent request and response for inspection. These are exported struct fields, updated after every command:</p> <pre><code>session.DisplayQueue(ctx, \"MY.QUEUE\")\n\nfmt.Println(session.LastCommandPayload)    // the JSON sent to MQ\nfmt.Println(session.LastResponsePayload)   // the parsed JSON response\nfmt.Println(session.LastHTTPStatus)        // HTTP status code\nfmt.Println(session.LastResponseText)      // raw response body\n</code></pre>"},{"location":"api/session/#exported-fields-and-accessors","title":"Exported fields and accessors","text":"Field / Method Type Description <code>LastHTTPStatus</code> <code>int</code> HTTP status code from last command <code>LastResponseText</code> <code>string</code> Raw response body from last command <code>LastResponsePayload</code> <code>map[string]any</code> Parsed response from last command <code>LastCommandPayload</code> <code>map[string]any</code> Command payload sent for last command <code>QmgrName()</code> <code>string</code> Queue manager name <code>GatewayQmgr()</code> <code>string</code> Gateway queue manager (or empty string)"},{"location":"api/sync/","title":"Sync","text":""},{"location":"api/sync/#overview","title":"Overview","text":"<p>The sync methods provide 9 synchronous start/stop/restart operations on <code>Session</code>. These methods wrap fire-and-forget <code>START</code> and <code>STOP</code> commands with a polling loop that waits until the object reaches its target state or the timeout expires.</p>"},{"location":"api/sync/#syncoperation","title":"SyncOperation","text":"<p>An integer enum indicating the operation that was performed:</p> <pre><code>const (\n    SyncStarted   SyncOperation = iota  // Object confirmed running\n    SyncStopped                         // Object confirmed stopped\n    SyncRestarted                       // Stop-then-start completed\n)\n</code></pre> <p><code>SyncOperation</code> implements <code>fmt.Stringer</code>, returning <code>\"started\"</code>, <code>\"stopped\"</code>, or <code>\"restarted\"</code>.</p>"},{"location":"api/sync/#syncconfig","title":"SyncConfig","text":"<p>A struct controlling the polling behavior:</p> <pre><code>type SyncConfig struct {\n    Timeout      time.Duration  // Max wait before returning TimeoutError (default 30s)\n    PollInterval time.Duration  // Duration between status checks (default 1s)\n}\n</code></pre> Field Type Description <code>Timeout</code> <code>time.Duration</code> Maximum duration to wait before returning <code>*TimeoutError</code> (default: 30s if zero) <code>PollInterval</code> <code>time.Duration</code> Duration between <code>DISPLAY *STATUS</code> polls (default: 1s if zero) <p>Zero values for <code>Timeout</code> and <code>PollInterval</code> are replaced with their defaults (30 seconds and 1 second respectively).</p>"},{"location":"api/sync/#syncresult","title":"SyncResult","text":"<p>A struct containing the outcome of a sync operation:</p> <pre><code>type SyncResult struct {\n    Operation      SyncOperation  // What happened: SyncStarted, SyncStopped, or SyncRestarted\n    Polls          int            // Number of status polls issued\n    ElapsedSeconds float64        // Wall-clock time taken\n}\n</code></pre> Field Type Description <code>Operation</code> <code>SyncOperation</code> What happened: <code>SyncStarted</code>, <code>SyncStopped</code>, or <code>SyncRestarted</code> <code>Polls</code> <code>int</code> Number of status polls issued <code>ElapsedSeconds</code> <code>float64</code> Wall-clock seconds from command to confirmation"},{"location":"api/sync/#method-signature-pattern","title":"Method signature pattern","text":"<p>All 9 sync methods share the same signature:</p> <pre><code>func (session *Session) StartChannelSync(\n    ctx    context.Context,\n    name   string,\n    config SyncConfig,\n) (SyncResult, error)\n</code></pre>"},{"location":"api/sync/#available-sync-methods","title":"Available sync methods","text":"Method Operation Object type <code>StartChannelSync()</code> Start Channel <code>StopChannelSync()</code> Stop Channel <code>RestartChannel()</code> Restart Channel <code>StartListenerSync()</code> Start Listener <code>StopListenerSync()</code> Stop Listener <code>RestartListener()</code> Restart Listener <code>StartServiceSync()</code> Start Service <code>StopServiceSync()</code> Stop Service <code>RestartService()</code> Restart Service"},{"location":"api/sync/#usage","title":"Usage","text":"<pre><code>ctx := context.Background()\n\n// Start a channel and wait for RUNNING status\nresult, err := session.StartChannelSync(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{})\nif err != nil {\n    var timeoutErr *mqrestadmin.TimeoutError\n    if errors.As(err, &amp;timeoutErr) {\n        fmt.Printf(\"Timed out after %.1fs\\n\", timeoutErr.ElapsedSeconds)\n    }\n    log.Fatal(err)\n}\nfmt.Printf(\"Channel %s after %d polls (%.1fs)\\n\",\n    result.Operation, result.Polls, result.ElapsedSeconds)\n\n// Custom polling configuration\nresult, err = session.StopChannelSync(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{\n    Timeout:      10 * time.Second,\n    PollInterval: 500 * time.Millisecond,\n})\n\n// Restart (stop then start, polling at each step)\nresult, err = session.RestartChannel(ctx, \"TO.PARTNER\", mqrestadmin.SyncConfig{})\n// result.Operation == SyncRestarted\n// result.Polls includes polls from both stop and start phases\n</code></pre> <p>See Sync Methods for the full conceptual overview, polling behavior, and status detection logic.</p>"},{"location":"api/transport/","title":"Transport","text":""},{"location":"api/transport/#overview","title":"Overview","text":"<p>The transport layer abstracts HTTP communication from the session logic. The session builds <code>runCommandJSON</code> payloads and delegates HTTP delivery to a transport implementation. This separation enables testing the entire command pipeline without an MQ server by injecting a mock transport.</p>"},{"location":"api/transport/#transport-interface","title":"Transport interface","text":"<p>The <code>Transport</code> interface defines a single method for posting JSON payloads:</p> <pre><code>type Transport interface {\n    PostJSON(\n        ctx       context.Context,\n        url       string,\n        payload   map[string]any,\n        headers   map[string]string,\n        timeout   time.Duration,\n        verifyTLS bool,\n    ) (*TransportResponse, error)\n}\n</code></pre> Parameter Type Description <code>ctx</code> <code>context.Context</code> Request context for cancellation and deadlines <code>url</code> <code>string</code> Fully-qualified endpoint URL <code>payload</code> <code>map[string]any</code> The <code>runCommandJSON</code> request body <code>headers</code> <code>map[string]string</code> Authentication, CSRF token, and optional gateway headers <code>timeout</code> <code>time.Duration</code> Per-request timeout duration <code>verifyTLS</code> <code>bool</code> Whether to verify server certificates <p>Returns <code>*TransportResponse</code> on success or a <code>*TransportError</code> on network failures.</p>"},{"location":"api/transport/#transportresponse","title":"TransportResponse","text":"<p>A struct containing the HTTP response data:</p> <pre><code>type TransportResponse struct {\n    StatusCode int               // HTTP status code\n    Body       string            // Response body (empty string if no body)\n    Headers    map[string]string // Response headers\n}\n</code></pre> Field Type Description <code>StatusCode</code> <code>int</code> HTTP status code <code>Body</code> <code>string</code> Response body text <code>Headers</code> <code>map[string]string</code> Response headers (first value per key)"},{"location":"api/transport/#httptransport","title":"HTTPTransport","text":"<p>The default <code>Transport</code> implementation using <code>net/http</code> from the Go standard library (zero external dependencies):</p> <pre><code>type HTTPTransport struct {\n    TLSConfig *tls.Config  // optional TLS configuration for mTLS or custom CAs\n}\n</code></pre> <pre><code>// Default -- verifies TLS certificates\ntransport := &amp;mqrestadmin.HTTPTransport{}\n\n// Custom TLS configuration for mTLS\ntransport := &amp;mqrestadmin.HTTPTransport{\n    TLSConfig: &amp;tls.Config{\n        Certificates: []tls.Certificate{cert},\n    },\n}\n</code></pre> <p><code>HTTPTransport</code> handles:</p> <ul> <li>HTTPS connections with configurable <code>tls.Config</code></li> <li>Automatic TLS certificate verification (or disabled via <code>verifyTLS=false</code>)</li> <li>Request timeouts via <code>time.Duration</code></li> <li>JSON serialization/deserialization with <code>encoding/json</code></li> <li>Custom HTTP headers</li> <li>Context-aware requests with cancellation support</li> </ul> <p>When <code>CertificateAuth</code> credentials are provided and no custom transport is set, <code>NewSession</code> automatically creates an <code>HTTPTransport</code> with the client certificate loaded into <code>TLSConfig</code>.</p>"},{"location":"api/transport/#injecting-a-custom-transport","title":"Injecting a custom transport","text":"<p>Use <code>WithTransport</code> to provide a custom <code>Transport</code> implementation for testing or specialized HTTP handling:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithTransport(mockTransport),\n)\n</code></pre>"},{"location":"api/transport/#mock-transport-for-testing","title":"Mock transport for testing","text":"<p>Because <code>Transport</code> is an interface with a single method, it is straightforward to create mock implementations for unit tests:</p> <pre><code>type mockTransport struct {\n    response *mqrestadmin.TransportResponse\n    err      error\n}\n\nfunc (m *mockTransport) PostJSON(\n    ctx context.Context, url string, payload map[string]any,\n    headers map[string]string, timeout time.Duration, verifyTLS bool,\n) (*mqrestadmin.TransportResponse, error) {\n    return m.response, m.err\n}\n\n// Use in tests\nmock := &amp;mockTransport{\n    response: &amp;mqrestadmin.TransportResponse{\n        StatusCode: 200,\n        Body:       `{\"commandResponse\":[]}`,\n        Headers:    map[string]string{},\n    },\n}\n\nsession, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.BasicAuth{Username: \"admin\", Password: \"passw0rd\"},\n    mqrestadmin.WithTransport(mock),\n)\n</code></pre> <p>This pattern is used extensively in the library's own test suite to verify command payload construction, response parsing, and error handling without network access.</p>"},{"location":"design/","title":"Design","text":"<p>These pages document design decisions and the MQ REST API protocol details that inform the library's architecture.</p> <ul> <li>Rationale \u2014 Why this library exists and key design choices</li> <li>runCommandJSON Endpoint \u2014 The MQ REST API endpoint</li> <li>Nested Object Flattening \u2014 Handling nested responses</li> </ul>"},{"location":"design/nested-object-flattening/","title":"Nested Object Flattening","text":""},{"location":"design/nested-object-flattening/#nested-object-flattening_1","title":"Nested Object Flattening","text":"<p>When attribute mapping is enabled (the default), the MQSC names are then translated to <code>snake_case</code>:</p> <pre><code>// After flattening and mapping, each result is a flat map:\n// map[string]any{\n//     \"object_name\":  \"MY.QUEUE\",\n//     \"handle_state\": \"ACTIVE\",\n//     ...\n// }\n</code></pre>"},{"location":"design/nested-object-flattening/#go-implementation","title":"Go implementation","text":"<p>In <code>mqrestadmin</code>, the flattening logic lives in the internal <code>flattenNestedObjects()</code> function. It processes <code>[]map[string]any</code> and returns a new <code>[]map[string]any</code> with all nesting resolved.</p> <p>The merge uses <code>maps.Clone()</code> from the standard library to copy the shared parent keys, then sets each nested-item key on the clone. Nested-item keys override any same-named parent keys.</p>"},{"location":"design/nested-object-flattening/#see-also","title":"See also","text":"<ul> <li>runCommandJSON endpoint -- general <code>runCommandJSON</code> request/response   structure</li> <li>rationale -- overall design rationale</li> <li>DISPLAY CONN --   IBM MQ documentation</li> <li>DISPLAY QSTATUS --   IBM MQ documentation</li> </ul> <p>When attribute mapping is enabled (the default), the MQSC names are then translated to <code>snake_case</code>:</p> <pre><code>// After flattening and mapping, each result is a flat map:\n// map[string]any{\n//     \"object_name\":  \"MY.QUEUE\",\n//     \"handle_state\": \"ACTIVE\",\n//     ...\n// }\n</code></pre>"},{"location":"design/nested-object-flattening/#go-implementation_1","title":"Go implementation","text":"<p>In <code>mqrestadmin</code>, the flattening logic lives in the internal <code>flattenNestedObjects()</code> function. It processes <code>[]map[string]any</code> and returns a new <code>[]map[string]any</code> with all nesting resolved.</p> <p>The merge uses <code>maps.Clone()</code> from the standard library to copy the shared parent keys, then sets each nested-item key on the clone. Nested-item keys override any same-named parent keys.</p>"},{"location":"design/nested-object-flattening/#see-also_1","title":"See also","text":"<ul> <li>runCommandJSON endpoint -- general <code>runCommandJSON</code> request/response   structure</li> <li>rationale -- overall design rationale</li> <li>DISPLAY CONN --   IBM MQ documentation</li> <li>DISPLAY QSTATUS --   IBM MQ documentation</li> </ul>"},{"location":"design/rationale/","title":"Design Rationale","text":""},{"location":"design/rationale/#design-rationale_1","title":"Design Rationale","text":""},{"location":"design/rationale/#go-specific-design-choices","title":"Go-specific design choices","text":""},{"location":"design/rationale/#zero-external-dependencies","title":"Zero external dependencies","text":"<p><code>mqrestadmin</code> has zero external runtime dependencies. The entire package is built on the Go standard library:</p> <ul> <li><code>net/http</code> for HTTP communication</li> <li><code>encoding/json</code> for JSON serialization</li> <li><code>crypto/tls</code> for TLS and mutual TLS</li> <li><code>embed</code> for mapping data resources</li> </ul> <p>This keeps the dependency tree empty and avoids version conflicts in downstream projects.</p>"},{"location":"design/rationale/#single-flat-package","title":"Single flat package","text":"<p>The entire public API lives in one package: <code>mqrestadmin</code>. There are no sub-packages to import. This follows the Go convention of small, focused packages and keeps the import path simple:</p> <pre><code>import \"github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\"\n</code></pre>"},{"location":"design/rationale/#functional-options","title":"Functional options","text":"<p>Session configuration uses the functional options pattern rather than a configuration struct or builder:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithVerifyTLS(false),\n    mqrestadmin.WithTimeout(30 * time.Second),\n)\n</code></pre> <p>This provides a clean API with sensible defaults, optional parameters without nil checks, and backward-compatible extensibility.</p>"},{"location":"design/rationale/#contextcontext-integration","title":"context.Context integration","text":"<p>All I/O methods accept <code>context.Context</code> as their first parameter:</p> <pre><code>results, err := session.DisplayQueue(ctx, \"MY.QUEUE\")\n</code></pre> <p>This enables cancellation, deadline propagation, and tracing integration without inventing a custom mechanism.</p>"},{"location":"design/rationale/#errors-as-values","title":"Errors as values","text":"<p>Go errors follow the standard <code>error</code> interface with typed error structs for classification:</p> <pre><code>results, err := session.DisplayQueue(ctx, \"MY.QUEUE\")\nif err != nil {\n    var cmdErr *mqrestadmin.CommandError\n    if errors.As(err, &amp;cmdErr) {\n        fmt.Printf(\"status: %d, payload: %v\\n\", cmdErr.StatusCode, cmdErr.Payload)\n    }\n    return err\n}\n</code></pre> <p>There is no exception hierarchy. Errors are values that can be inspected with <code>errors.As()</code> and <code>errors.Is()</code>.</p>"},{"location":"design/rationale/#method-naming-conventions","title":"Method naming conventions","text":"<p>Command methods use <code>PascalCase</code> following Go export conventions. The pattern is <code>&lt;Verb&gt;&lt;Qualifier&gt;</code>:</p> MQSC command Go method <code>DISPLAY QUEUE</code> <code>DisplayQueue()</code> <code>DEFINE QLOCAL</code> <code>DefineQlocal()</code> <code>DELETE CHANNEL</code> <code>DeleteChannel()</code> <code>ALTER QMGR</code> <code>AlterQmgr()</code>"},{"location":"design/rationale/#return-shapes","title":"Return shapes","text":"<p>DISPLAY commands return <code>([]map[string]any, error)</code>. An empty slice means no objects matched -- this is not an error. The caller can range over the result without nil checks.</p> <p>Queue manager singletons (<code>DisplayQmgr</code>, <code>DisplayQmstatus</code>, etc.) return <code>(map[string]any, error)</code>. A nil map means no result was returned.</p> <p>Non-DISPLAY commands (<code>Define</code>, <code>Delete</code>, <code>Alter</code>, etc.) return <code>error</code> only. A nil error means success.</p>"},{"location":"design/rationale/#go-specific-design-choices_1","title":"Go-specific design choices","text":""},{"location":"design/rationale/#zero-external-dependencies_1","title":"Zero external dependencies","text":"<p><code>mqrestadmin</code> has zero external runtime dependencies. The entire package is built on the Go standard library:</p> <ul> <li><code>net/http</code> for HTTP communication</li> <li><code>encoding/json</code> for JSON serialization</li> <li><code>crypto/tls</code> for TLS and mutual TLS</li> <li><code>embed</code> for mapping data resources</li> </ul> <p>This keeps the dependency tree empty and avoids version conflicts in downstream projects.</p>"},{"location":"design/rationale/#single-flat-package_1","title":"Single flat package","text":"<p>The entire public API lives in one package: <code>mqrestadmin</code>. There are no sub-packages to import. This follows the Go convention of small, focused packages and keeps the import path simple:</p> <pre><code>import \"github.com/wphillipmoore/mq-rest-admin-go/mqrestadmin\"\n</code></pre>"},{"location":"design/rationale/#functional-options_1","title":"Functional options","text":"<p>Session configuration uses the functional options pattern rather than a configuration struct or builder:</p> <pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM1\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithVerifyTLS(false),\n    mqrestadmin.WithTimeout(30 * time.Second),\n)\n</code></pre> <p>This provides a clean API with sensible defaults, optional parameters without nil checks, and backward-compatible extensibility.</p>"},{"location":"design/rationale/#contextcontext-integration_1","title":"context.Context integration","text":"<p>All I/O methods accept <code>context.Context</code> as their first parameter:</p> <pre><code>results, err := session.DisplayQueue(ctx, \"MY.QUEUE\")\n</code></pre> <p>This enables cancellation, deadline propagation, and tracing integration without inventing a custom mechanism.</p>"},{"location":"design/rationale/#errors-as-values_1","title":"Errors as values","text":"<p>Go errors follow the standard <code>error</code> interface with typed error structs for classification:</p> <pre><code>results, err := session.DisplayQueue(ctx, \"MY.QUEUE\")\nif err != nil {\n    var cmdErr *mqrestadmin.CommandError\n    if errors.As(err, &amp;cmdErr) {\n        fmt.Printf(\"status: %d, payload: %v\\n\", cmdErr.StatusCode, cmdErr.Payload)\n    }\n    return err\n}\n</code></pre> <p>There is no exception hierarchy. Errors are values that can be inspected with <code>errors.As()</code> and <code>errors.Is()</code>.</p>"},{"location":"design/rationale/#method-naming-conventions_1","title":"Method naming conventions","text":"<p>Command methods use <code>PascalCase</code> following Go export conventions. The pattern is <code>&lt;Verb&gt;&lt;Qualifier&gt;</code>:</p> MQSC command Go method <code>DISPLAY QUEUE</code> <code>DisplayQueue()</code> <code>DEFINE QLOCAL</code> <code>DefineQlocal()</code> <code>DELETE CHANNEL</code> <code>DeleteChannel()</code> <code>ALTER QMGR</code> <code>AlterQmgr()</code>"},{"location":"design/rationale/#return-shapes_1","title":"Return shapes","text":"<p>DISPLAY commands return <code>([]map[string]any, error)</code>. An empty slice means no objects matched -- this is not an error. The caller can range over the result without nil checks.</p> <p>Queue manager singletons (<code>DisplayQmgr</code>, <code>DisplayQmstatus</code>, etc.) return <code>(map[string]any, error)</code>. A nil map means no result was returned.</p> <p>Non-DISPLAY commands (<code>Define</code>, <code>Delete</code>, <code>Alter</code>, etc.) return <code>error</code> only. A nil error means success.</p>"},{"location":"design/runcommand-endpoint/","title":"The runCommandJSON Endpoint","text":""},{"location":"design/runcommand-endpoint/#the-runcommandjson-endpoint_1","title":"The runCommandJSON Endpoint","text":""},{"location":"design/runcommand-endpoint/#nested-object-flattening","title":"Nested object flattening","text":"<p>Some commands (<code>DISPLAY CONN TYPE(HANDLE)</code>, <code>DISPLAY QSTATUS TYPE(HANDLE)</code>) return responses where each <code>commandResponse</code> item contains an <code>objects</code> array of per-handle attributes alongside parent-scoped attributes. <code>mqrestadmin</code> automatically detects and flattens these structures so that every command returns uniform flat maps:</p> <pre><code>{\"conn\": \"A1B2C3D4E5F6\", \"objname\": \"MY.QUEUE\", \"hstate\": \"ACTIVE\"}\n</code></pre> <p>See nested object flattening for the full algorithm, edge cases, and before/after examples.</p>"},{"location":"design/runcommand-endpoint/#go-implementation-notes","title":"Go implementation notes","text":"<p>In <code>mqrestadmin</code>, the error handling described above is implemented using typed error structs:</p> <ul> <li>Non-zero overall codes produce a <code>*CommandError</code> with the full response   payload attached.</li> <li>DISPLAY commands with no matches (reason code 2085) return an empty   slice and nil error.</li> <li>The CSRF token defaults to <code>\"local\"</code> and can be overridden via   <code>WithCSRFToken(&amp;token)</code>, or omitted with <code>WithCSRFToken(nil)</code>.</li> <li>Authentication is configured via credential structs passed to <code>NewSession()</code>:   <code>BasicAuth{}</code>, <code>CertificateAuth{}</code>, or <code>LTPAAuth{}</code>.</li> </ul>"},{"location":"design/runcommand-endpoint/#nested-object-flattening_1","title":"Nested object flattening","text":"<p>Some commands (<code>DISPLAY CONN TYPE(HANDLE)</code>, <code>DISPLAY QSTATUS TYPE(HANDLE)</code>) return responses where each <code>commandResponse</code> item contains an <code>objects</code> array of per-handle attributes alongside parent-scoped attributes. <code>mqrestadmin</code> automatically detects and flattens these structures so that every command returns uniform flat maps:</p> <pre><code>{\"conn\": \"A1B2C3D4E5F6\", \"objname\": \"MY.QUEUE\", \"hstate\": \"ACTIVE\"}\n</code></pre> <p>See nested object flattening for the full algorithm, edge cases, and before/after examples.</p>"},{"location":"design/runcommand-endpoint/#go-implementation-notes_1","title":"Go implementation notes","text":"<p>In <code>mqrestadmin</code>, the error handling described above is implemented using typed error structs:</p> <ul> <li>Non-zero overall codes produce a <code>*CommandError</code> with the full response   payload attached.</li> <li>DISPLAY commands with no matches (reason code 2085) return an empty   slice and nil error.</li> <li>The CSRF token defaults to <code>\"local\"</code> and can be overridden via   <code>WithCSRFToken(&amp;token)</code>, or omitted with <code>WithCSRFToken(nil)</code>.</li> <li>Authentication is configured via credential structs passed to <code>NewSession()</code>:   <code>BasicAuth{}</code>, <code>CertificateAuth{}</code>, or <code>LTPAAuth{}</code>.</li> </ul>"},{"location":"development/","title":"Development","text":"<p>Guides for contributors and developers working on mqrestadmin.</p> <ul> <li>Developer Setup -- Build environment and tools</li> <li>Contributing -- How to contribute</li> <li>Local MQ Container -- Running MQ locally for testing</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>This project welcomes contributions from humans working with or without AI assistance. AI tooling is available but not required.</p>"},{"location":"development/contributing/#branching-and-workflow","title":"Branching and workflow","text":"<p>All contributors follow the same branching model:</p> <ul> <li>Branch from <code>develop</code> using <code>feature/*</code>, <code>bugfix/*</code>, <code>hotfix/*</code>, or   <code>chore/*</code> prefixes.</li> <li>Commit messages follow   conventional commits and are   validated by CI.</li> <li>Feature PRs: squash merge to <code>develop</code>.</li> <li>Release PRs: regular merge to <code>main</code> (preserves shared ancestry).</li> </ul>"},{"location":"development/contributing/#commit-conventions","title":"Commit conventions","text":"<p>Commits must follow the Conventional Commits format:</p> <pre><code>&lt;type&gt;: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>style</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p>"},{"location":"development/contributing/#code-quality-requirements","title":"Code quality requirements","text":"<p>All code must pass quality checks before merging:</p> <ul> <li>Static analysis: <code>go vet ./...</code></li> <li>Tests: <code>go test -race ./...</code></li> <li>Build: <code>go build ./...</code></li> </ul> <p>Run all checks locally before pushing:</p> <pre><code>go build ./... &amp;&amp; go vet ./... &amp;&amp; go test -race ./...\n</code></pre>"},{"location":"development/contributing/#pull-request-process","title":"Pull request process","text":"<ol> <li>Create a <code>feature/*</code> branch from <code>develop</code></li> <li>Make changes and ensure all checks pass</li> <li>Open a PR targeting <code>develop</code></li> <li>CI runs the full validation pipeline</li> <li>After review and approval, squash-merge into <code>develop</code></li> </ol>"},{"location":"development/contributing/#for-human-contributors","title":"For human contributors","text":"<ul> <li>Run quality checks before pushing to catch issues early.</li> <li>Reference <code>docs/repository-standards.md</code> for the full standards   specification.</li> <li>The <code>CLAUDE.md</code> and <code>AGENTS.md</code> files document architecture,   patterns, and key design decisions. They are useful as reference   material even when not using an AI agent.</li> </ul>"},{"location":"development/contributing/#for-ai-agent-contributors","title":"For AI agent contributors","text":""},{"location":"development/contributing/#agent-entry-points","title":"Agent entry points","text":"<ul> <li>Claude Code: reads <code>CLAUDE.md</code>, which loads repository standards   via include directives.</li> <li>Codex and other agents: reads <code>AGENTS.md</code>, which loads the same   standards plus shared skills from the <code>standards-and-conventions</code>   repository.</li> </ul>"},{"location":"development/contributing/#quality-expectations","title":"Quality expectations","text":"<p>AI-generated code must pass all the same validation gates listed above. There are no exceptions.</p>"},{"location":"development/contributing/#co-author-trailers","title":"Co-author trailers","text":"<p>AI agents add co-author trailers to commits automatically when following the repository standards.</p>"},{"location":"development/developer-setup/","title":"Developer Setup","text":""},{"location":"development/developer-setup/#prerequisites","title":"Prerequisites","text":"Tool Version Purpose Go 1.25+ Build and test git Latest Version control Docker Latest Local MQ containers (integration tests) <p>No external build tools, task runners, or code generators are required. The Go toolchain provides everything needed.</p>"},{"location":"development/developer-setup/#required-repositories","title":"Required repositories","text":"<p>mqrestadmin depends on two sibling repositories:</p> Repository Purpose mq-rest-admin-go This project standards-and-conventions Canonical project standards (referenced by <code>AGENTS.md</code> and git hooks) mq-dev-environment Dockerized MQ test infrastructure (local and CI)"},{"location":"development/developer-setup/#recommended-directory-layout","title":"Recommended directory layout","text":"<p>Clone all three repositories as siblings:</p> <pre><code>~/dev/\n\u251c\u2500\u2500 mq-rest-admin-go/\n\u251c\u2500\u2500 standards-and-conventions/\n\u2514\u2500\u2500 mq-dev-environment/\n</code></pre> <pre><code>cd ~/dev\ngit clone https://github.com/wphillipmoore/mq-rest-admin-go.git\ngit clone https://github.com/wphillipmoore/standards-and-conventions.git\ngit clone https://github.com/wphillipmoore/mq-dev-environment.git\n</code></pre>"},{"location":"development/developer-setup/#building","title":"Building","text":"<pre><code>go build ./...          # Compile all packages\ngo vet ./...            # Run static analysis\n</code></pre> <p>There is no separate clean step -- Go caches builds automatically and invalidates when source files change.</p>"},{"location":"development/developer-setup/#testing","title":"Testing","text":"<pre><code>go test ./...                          # Run all unit tests\ngo test -v ./...                       # Verbose output\ngo test -race ./...                    # Race detector enabled\ngo test -cover ./...                   # Show coverage summary\ngo test -coverprofile=coverage.out ./...  # Generate coverage profile\ngo tool cover -html=coverage.out       # View coverage in browser\n</code></pre>"},{"location":"development/developer-setup/#validation","title":"Validation","text":"<p>Run all quality checks:</p> <pre><code>go build ./...          # Compile\ngo vet ./...            # Static analysis\ngo test -race ./...     # Tests with race detector\n</code></pre>"},{"location":"development/developer-setup/#git-hooks","title":"Git hooks","text":"<p>Enable repository git hooks before committing:</p> <pre><code>git config core.hooksPath scripts/git-hooks\n</code></pre> <p>The hooks enforce:</p> <ul> <li>pre-commit: Branch naming conventions and protected branch rules</li> <li>commit-msg: Conventional Commits format and co-author trailer validation</li> </ul>"},{"location":"development/developer-setup/#documentation","title":"Documentation","text":""},{"location":"development/developer-setup/#local-setup","title":"Local setup","text":"<pre><code># Set up shared fragments symlink\nscripts/dev/docs-setup.sh\n\n# Install MkDocs\npip install mkdocs-material\n\n# Build the documentation site\nmkdocs build -f docs/site/mkdocs.yml\n\n# Serve locally with live reload\nmkdocs serve -f docs/site/mkdocs.yml\n</code></pre>"},{"location":"development/local-mq-container/","title":"Local MQ Container","text":""},{"location":"development/local-mq-container/#local-mq-container_1","title":"Local MQ Container","text":""},{"location":"development/local-mq-container/#go-specific-notes","title":"Go-specific notes","text":""},{"location":"development/local-mq-container/#running-integration-tests","title":"Running integration tests","text":"<pre><code># Start MQ and seed configuration\nscripts/dev/mq_start.sh\nscripts/dev/mq_seed.sh\n\n# Run integration tests\nMQ_REST_ADMIN_RUN_INTEGRATION=1 go test -v ./...\n\n# Stop MQ when done\nscripts/dev/mq_stop.sh\n</code></pre>"},{"location":"development/local-mq-container/#environment-variables","title":"Environment variables","text":"Variable Default Description <code>MQ_REST_ADMIN_RUN_INTEGRATION</code> (unset) Set to <code>1</code> to enable integration tests"},{"location":"development/local-mq-container/#gateway-routing-example","title":"Gateway routing example","text":"<pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM2\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithGatewayQmgr(\"QM1\"),\n    mqrestadmin.WithVerifyTLS(false),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nctx := context.Background()\nqmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(qmgr) // QM2's attributes, routed through QM1\n</code></pre>"},{"location":"development/local-mq-container/#go-specific-notes_1","title":"Go-specific notes","text":""},{"location":"development/local-mq-container/#running-integration-tests_1","title":"Running integration tests","text":"<pre><code># Start MQ and seed configuration\nscripts/dev/mq_start.sh\nscripts/dev/mq_seed.sh\n\n# Run integration tests\nMQ_REST_ADMIN_RUN_INTEGRATION=1 go test -v ./...\n\n# Stop MQ when done\nscripts/dev/mq_stop.sh\n</code></pre>"},{"location":"development/local-mq-container/#environment-variables_1","title":"Environment variables","text":"Variable Default Description <code>MQ_REST_ADMIN_RUN_INTEGRATION</code> (unset) Set to <code>1</code> to enable integration tests"},{"location":"development/local-mq-container/#gateway-routing-example_1","title":"Gateway routing example","text":"<pre><code>session, err := mqrestadmin.NewSession(\n    \"https://localhost:9443/ibmmq/rest/v2\",\n    \"QM2\",\n    mqrestadmin.LTPAAuth{Username: \"mqadmin\", Password: \"mqadmin\"},\n    mqrestadmin.WithGatewayQmgr(\"QM1\"),\n    mqrestadmin.WithVerifyTLS(false),\n)\nif err != nil {\n    log.Fatal(err)\n}\n\nctx := context.Background()\nqmgr, err := session.DisplayQmgr(ctx)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(qmgr) // QM2's attributes, routed through QM1\n</code></pre>"}]}